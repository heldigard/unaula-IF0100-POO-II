<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Dominar pytest avanzado: fixtures, parametrizaci√≥n y mocks. Curso IF0100 - POO II">
    <meta name="author" content="IF0100 - UNAULA">
    <title>pytest Avanzado | IF0100 - POO II</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
          crossorigin="anonymous">

    <!-- Prism.js para syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
          rel="stylesheet">

    <style>
        :root {
            --primary-color: #0d6efd;
            --secondary-color: #6c757d;
            --success-color: #198754;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #0dcaf0;
            --light-bg: #f8f9fa;
            --dark-text: #212529;
            --border-color: #dee2e6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.7;
            color: var(--dark-text);
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, var(--primary-color) 0%, #0a58ca 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        header h2 {
            font-size: 1.25rem;
            font-weight: 400;
            opacity: 0.9;
        }

        header h3 {
            font-size: 1rem;
            font-weight: 300;
            opacity: 0.8;
        }

        /* Navigation */
        .navbar {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Sidebar */
        .sidebar {
            background-color: var(--light-bg);
            border-radius: 8px;
            padding: 1.5rem;
            position: sticky;
            top: 2rem;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .sidebar h5 {
            color: var(--primary-color);
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary-color);
        }

        .sidebar ul {
            list-style: none;
            padding-left: 0;
        }

        .sidebar li {
            margin-bottom: 0.5rem;
        }

        .sidebar a {
            color: var(--dark-text);
            text-decoration: none;
            padding: 0.5rem 0.75rem;
            display: block;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .sidebar a:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateX(5px);
        }

        /* Main Content */
        main {
            padding: 2rem 0;
        }

        section {
            margin-bottom: 3rem;
            padding: 1.5rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        section h2 {
            color: var(--primary-color);
            font-weight: 600;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 3px solid var(--primary-color);
        }

        section h3 {
            color: var(--dark-text);
            font-weight: 500;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
        }

        section h4 {
            color: var(--secondary-color);
            font-weight: 500;
            margin-top: 1rem;
            margin-bottom: 0.75rem;
        }

        /* Lists */
        section ul, section ol {
            padding-left: 1.5rem;
            margin-bottom: 1rem;
        }

        section li {
            margin-bottom: 0.5rem;
        }

        /* Code Blocks */
        pre[class*="language-"] {
            border-radius: 6px;
            margin: 1rem 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        code[class*="language-"] {
            font-size: 0.9rem;
        }

        /* Alert Boxes */
        .alert-note {
            background-color: #e7f3ff;
            border-left: 4px solid var(--info-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .alert-warning-custom {
            background-color: #fff3cd;
            border-left: 4px solid var(--warning-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .alert-tip {
            background-color: #d1e7dd;
            border-left: 4px solid var(--success-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .alert-error {
            background-color: #f8d7da;
            border-left: 4px solid var(--danger-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        /* Cards */
        .card {
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        /* Tables */
        .table {
            margin: 1rem 0;
        }

        .table thead {
            background-color: var(--primary-color);
            color: white;
        }

        /* Fixture Diagram */
        .fixture-flow {
            background: linear-gradient(to right, #e3f2fd, #bbdefb);
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .fixture-step {
            text-align: center;
            margin: 0.5rem 0;
        }

        /* Footer */
        footer {
            background-color: var(--light-bg);
            padding: 2rem 0;
            margin-top: 3rem;
            text-align: center;
            border-top: 1px solid var(--border-color);
        }

        footer p {
            margin-bottom: 0.5rem;
            color: var(--secondary-color);
        }

        /* Print Styles */
        @media print {
            header {
                background: white !important;
                color: black !important;
                padding: 1rem 0;
            }

            .navbar, .sidebar, footer {
                display: none;
            }

            section {
                page-break-inside: avoid;
                box-shadow: none;
                border: 1px solid var(--border-color);
            }

            a {
                color: black;
                text-decoration: none;
            }

            a[href]:after {
                content: " (" attr(href) ")";
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.5rem;
            }

            header h2 {
                font-size: 1rem;
            }

            .sidebar {
                position: static;
                max-height: none;
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <div class="container">
            <h1>IF0100 - Lenguaje de Programaci√≥n OO II</h1>
            <h2>Unidad 2: T√©cnicas de Desarrollo</h2>
            <h3>Clase 02: pytest Avanzado</h3>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                    data-bs-target="#navbarNav"
                    aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html">Inicio</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#clases">Clases</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#recursos">Recursos</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <!-- Sidebar -->
            <aside class="col-lg-3">
                <nav class="sidebar">
                    <h5>Contenido</h5>
                    <ul>
                        <li><a href="#objetivos">Objetivos de Aprendizaje</a></li>
                        <li><a href="#teoria">Conceptos Te√≥ricos</a></li>
                        <li><a href="#fixtures">Fixtures en pytest</a></li>
                        <li><a href="#parametrizacion">Parametrizaci√≥n</a></li>
                        <li><a href="#mocks">Mocks y Monkeypatch</a></li>
                        <li><a href="#ejemplos">Ejemplos Pr√°cticos</a></li>
                        <li><a href="#buenas-practicas">Buenas Pr√°cticas</a></li>
                        <li><a href="#ejercicio">Ejercicio Guido</a></li>
                        <li><a href="#referencias">Para Profundizar</a></li>
                    </ul>
                </nav>
            </aside>

            <!-- Main Content Area -->
            <main class="col-lg-9">
                <!-- Secci√≥n 1: Objetivos -->
                <section id="objetivos">
                    <h2>Objetivos de Aprendizaje</h2>
                    <p>Al finalizar esta clase, usted ser√° capaz de:</p>
                    <ul>
                        <li>Crear y usar fixtures de pytest para setup compartido</li>
                        <li>Aplicar scopes de fixtures (function, class, module, session)</li>
                        <li>Usar parametrizaci√≥n para ejecutar tests con m√∫ltiples datos</li>
                        <li>Crear mocks y patches con unittest.mock</li>
                        <li>Aplicar monkeypatch para modificar comportamiento en tests</li>
                        <li>Organizar tests en clases y usar fixtures de conftest.py</li>
                    </ul>
                </section>

                <!-- Secci√≥n 2: Conceptos Te√≥ricos -->
                <section id="teoria">
                    <h2>Conceptos Te√≥ricos</h2>

                    <h3>¬øPor qu√© pytest Avanzado?</h3>
                    <p>
                        En la clase anterior aprendimos lo b√°sico de pytest: escribir tests con <code>assert</code>.
                        Ahora vamos a explorar caracter√≠sticas avanzadas que hacen que nuestros tests sean:
                    </p>
                    <ul>
                        <li><strong>M√°s mantenibles:</strong> Fixtures eliminan duplicaci√≥n</li>
                        <li><strong>M√°s completos:</strong> Parametrizaci√≥n prueba m√°s casos</li>
                        <li><strong>M√°s aislados:</strong> Mocks aislan dependencias externas</li>
                    </ul>

                    <h3>Fixtures: El Poder de pytest</h3>
                    <p>
                        Una <strong>fixture</strong> es una funci√≥n que prepara el entorno para un test.
                        Puede crear datos, inicializar recursos, configurar estado, etc.
                    </p>

                    <div class="alert-tip">
                        <strong> Analog√≠a:</strong> Una fixture es como el "setup" de un laboratorio
                        antes de un experimento. Prepara todo lo necesario para que el test se ejecute.
                    </div>

                    <h4>Ventajas de Usar Fixtures</h4>
                    <ul>
                        <li><strong>Reutilizaci√≥n:</strong> Escribir una vez, usar en muchos tests</li>
                        <li><strong>Legibilidad:</strong> Los tests son m√°s claros y enfocados</li>
                        <li><strong>Mantenibilidad:</strong> Cambios en un lugar afectan todos los tests</li>
                        <li><strong>inyecci√≥n de dependencias:</strong> pytest las inyecta autom√°ticamente</li>
                    </ul>

                    <h3>Parametrizaci√≥n: Un Test, Muchos Datos</h3>
                    <p>
                        La <strong>parametrizaci√≥n</strong> permite ejecutar el mismo test con diferentes
                        entradas, generando m√∫ltiples casos de prueba autom√°ticamente.
                    </p>

                    <h3>Mocks: Aislando Dependencias</h3>
                    <p>
                        Un <strong>mock</strong> es un objeto simulado que imita el comportamiento de
                        objetos reales. Nos permite probar c√≥digo en aislamiento sin dependencias externas.
                    </p>

                    <div class="alert-warning-custom">
                        <strong>¬øCu√°ndo usar mocks?</strong>
                        <ul>
                            <li>Cuando el c√≥digo depende de servicios externos (API, BD)</li>
                            <li>Cuando queremos probar comportamiento espec√≠fico</li>
                            <li>Cuando queremos simular errores o casos borde</li>
                            <li>Cuando las dependencias son lentas o no deterministas</li>
                        </ul>
                    </div>
                </section>

                <!-- Secci√≥n 3: Fixtures en pytest -->
                <section id="fixtures">
                    <h2>Fixtures en pytest</h2>

                    <h3>Sintaxis B√°sica</h3>
                    <pre><code class="language-python">import pytest

@pytest.fixture
def usuario():
    """Fixture que crea un usuario de prueba."""
    from taskflow.models.usuario import Usuario
    return Usuario(username="testuser", email="test@example.com")

def test_username(usuario):  # pytest inyecta la fixture autom√°ticamente
    """Test que el username es correcto."""
    assert usuario.username == "testuser"
    assert usuario.email == "test@example.com"</code></pre>

                    <h3>Fixture con Setup y Teardown</h3>
                    <div class="fixture-flow">
                        <div class="fixture-step">üîß <strong>SETUP:</strong> yield antes del c√≥digo</div>
                        <div class="fixture-step">üß™ <strong>TEST:</strong> c√≥digo del test se ejecuta</div>
                        <div class="fixture-step">üßπ <strong>TEARDOWN:</strong> c√≥digo despu√©s de yield</div>
                    </div>

                    <pre><code class="language-python">import pytest

@pytest.fixture
def archivo_temporal():
    """Fixture que crea un archivo temporal y lo limpia despu√©s."""
    import tempfile
    import os

    # SETUP: Crear archivo temporal
    fd, ruta = tempfile.mkstemp()
    with os.fdopen(fd, 'w') as f:
        f.write("contenido de prueba")

    # Yield el objeto al test
    yield ruta

    # TEARDOWN: Limpiar archivo
    os.unlink(ruta)

def test_leer_archivo_temporal(archivo_temporal):
    """Test que lee el archivo temporal creado por la fixture."""
    with open(archivo_temporal, 'r') as f:
        contenido = f.read()

    assert contenido == "contenido de prueba"

# El archivo temporal ya fue eliminado aqu√≠</code></pre>

                    <h3>Scopes de Fixtures</h3>
                    <p>
                        El scope define cu√°ntas veces se crea la fixture durante la ejecuci√≥n de tests.
                    </p>

                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Scope</th>
                                <th>Frecuencia</th>
                                <th>Uso T√≠pico</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>function</code> (default)</td>
                                <td>Una vez por test</td>
                                <td>Datos espec√≠ficos del test</td>
                            </tr>
                            <tr>
                                <td><code>class</code></td>
                                <td>Una vez por clase de tests</td>
                                <td>Setup compartido por clase</td>
                            </tr>
                            <tr>
                                <td><code>module</code></td>
                                <td>Una vez por m√≥dulo</td>
                                <td>Recursos costosos (conexi√≥n BD)</td>
                            </tr>
                            <tr>
                                <td><code>session</code></td>
                                <td>Una vez por sesi√≥n de pytest</td>
                                <td>Recursos globales (configuraci√≥n)</td>
                            </tr>
                        </tbody>
                    </table>

                    <pre><code class="language-python">import pytest

@pytest.fixture(scope="module")
def conexion_db():
    """Fixture de m√≥dulo: una conexi√≥n compartida para todos los tests."""
    print("\n[SETUP] Creando conexi√≥n a BD...")
    conexion = {"conexion": "simulada", "datos": []}
    yield conexion
    print("\n[TEARDOWN] Cerrando conexi√≥n a BD...")

def test_agregar_dato(conexion_db):
    """Test que agrega un dato a la BD."""
    conexion_db["datos"].append("dato1")
    assert len(conexion_db["datos"]) == 1

def test_agregar_otro_dato(conexion_db):
    """Test que agrega otro dato (conexion_db conserva estado)."""
    conexion_db["datos"].append("dato2")
    # dato1 sigue ah√≠ porque es la misma conexi√≥n
    assert len(conexion_db["datos"]) == 2</code></pre>

                    <h3>Fixture que Retorna M√∫ltiples Valores</h3>
                    <pre><code class="language-python">@pytest.fixture
def usuario_y_proyecto():
    """Fixture que retorna m√∫ltiples valores."""
    from taskflow.models.usuario import Usuario
    from taskflow.models.proyecto import Proyecto

    usuario = Usuario(username="jdoe", email="john@example.com")
    proyecto = Proyecto(nombre="TaskFlow", usuario_id=1)

    return usuario, proyecto  # Retorna tupla

def test_usuario_tiene_proyecto(usuario_y_proyecto):
    """Test que usuario tiene proyecto."""
    usuario, proyecto = usuario_y_proyecto  # Desempaquetar

    assert usuario.username == "jdoe"
    assert proyecto.nombre == "TaskFlow"
    assert proyecto.usuario_id == 1</code></pre>

                    <h3>Usar una Fixture en Otra</h3>
                    <pre><code class="language-python">@pytest.fixture
def usuario():
    """Fixture base: usuario."""
    return Usuario(username="test", email="test@example.com")

@pytest.fixture
def proyecto_con_usuario(usuario):  # Depende de la fixture 'usuario'
    """Fixture que usa otra fixture."""
    return Proyecto(nombre="Proyecto Test", usuario_id=usuario.id)

def test_proyecto_tiene_usuario(proyecto_con_usuario, usuario):
    """Test que el proyecto est√° asociado al usuario."""
    assert proyecto_con_usuario.usuario_id == usuario.id</code></pre>

                    <h3>conftest.py: Fixtures Compartidas</h3>
                    <p>
                        El archivo <code>conftest.py</code> permite compartir fixtures entre m√∫ltiples
                        archivos de tests. pytest lo descubre autom√°ticamente.
                    </p>

                    <pre><code class="language-python"># tests/conftest.py
import pytest
from taskflow.models.usuario import Usuario
from taskflow.models.proyecto import Proyecto

@pytest.fixture
def usuario_base():
    """Fixture compartida por todos los tests."""
    return Usuario(username="base", email="base@example.com")

@pytest.fixture
def proyecto_base():
    """Otra fixture compartida."""
    return Proyecto(nombre="Proyecto Base", usuario_id=1)

# tests/test_usuario.py
def test_usa_fixture_compartida(usuario_base):
    """Test que usa fixture de conftest.py."""
    assert usuario_base.username == "base"

# tests/test_proyecto.py
def test_tambien_usa_fixture_compartida(usuario_base, proyecto_base):
    """Test en otro archivo que usa las mismas fixtures."""
    assert proyecto_base.nombre == "Proyecto Base"</code></pre>
                </section>

                <!-- Secci√≥n 4: Parametrizaci√≥n -->
                <section id="parametrizacion">
                    <h2>Parametrizaci√≥n</h2>

                    <h3>B√°sico: @pytest.mark.parametrize</h3>
                    <pre><code class="language-python">import pytest

@pytest.mark.parametrize("email, esperado", [
    ("usuario@example.com", True),     # Email v√°lido
    ("user.name@example.com", True),   # Email con punto
    ("user+tag@example.com", True),    # Email con +
    ("invalido", False),               # Sin @
    ("@example.com", False),           # Sin usuario
    ("usuario@", False),               # Sin dominio
])
def test_validar_email(email, esperado):
    """Test parametrizado que valida m√∫ltiples emails."""
    from taskflow.utils import validar_email

    resultado = validar_email(email)
    assert resultado == esperado</code></pre>

                    <p>Al ejecutar, pytest genera un test por cada caso:</p>
                    <pre><code class="language-bash">$ pytest tests/test_utils.py -v
...
test_validar_email[usuario@example.com-True] PASSED
test_validar_email[user.name@example.com-True] PASSED
test_validar_email[user+tag@example.com-True] PASSED
test_validar_email[invalido-False] PASSED
test_validar_email[@example.com-False] PASSED
test_validar_email[usuario@-False] PASSED</code></pre>

                    <h3>M√∫ltiples Par√°metros</h3>
                    <pre><code class="language-python">@pytest.mark.parametrize("username, email, valido", [
    ("abc", "test@example.com", False),     # Username muy corto
    ("valido", "test@example.com", True),   # Todo v√°lido
    ("valido", "invalido", False),          # Email inv√°lido
    ("ab", "test@example.com", False),      # Ambos inv√°lidos
])
def test_validar_usuario(username, email, valido):
    """Test parametrizado con m√∫ltiples campos."""
    from taskflow.models.usuario import Usuario

    usuario = Usuario(username=username, email=email)
    assert usuario.es_valido() == valido</code></pre>

                    <h3>Parametrizaci√≥n con IDs</h3>
                    <pre><code class="language-python">@pytest.mark.parametrize("entrada, esperado", [
    ("admin", True),           # admin-1
    ("user", False),           # user-2
    ("superuser", True),       # superuser-3
], ids=["admin-access", "user-access", "super-access"])
def test_verificar_permiso(entrada, esperado):
    """Test con IDs personalizados."""
    from taskflow.auth import tiene_permiso_admin

    resultado = tiene_permiso_admin(entrada)
    assert resultado == esperado</code></pre>

                    <h3>Combinar M√∫ltiples Parametrize</h3>
                    <pre><code class="language-python">@pytest.mark.parametrize("username", ["user1", "user2"])
@pytest.mark.parametrize("email", ["valid@example.com", "invalido"])
def test_combinaciones(username, email):
    """Este test se ejecuta 2 x 2 = 4 veces."""
    usuario = Usuario(username=username, email=email)
    print(f"Probando: {username} + {email}")
    # ... asserts</code></pre>

                    <h3>Parametrizaci√≥n con Fixtures</h3>
                    <pre><code class="language-python">@pytest.fixture
def datos_usuarios():
    """Fixture que retorna datos de prueba."""
    return [
        ("user1", "user1@example.com", True),
        ("ab", "user2@example.com", False),  # Username corto
        ("user3", "invalido", False),        # Email inv√°lido
    ]

@pytest.mark.parametrize("username, email, esperado", [
    ("user1", "user1@example.com", True),
    ("ab", "user2@example.com", False),
    ("user3", "invalido", False),
])
def test_con_fixture_y_parametrize(usuario_base, username, email, esperado):
    """Combina fixture y parametrizaci√≥n."""
    usuario = Usuario(username=username, email=email)
    assert usuario.es_valido() == esperado</code></pre>
                </section>

                <!-- Secci√≥n 5: Mocks y Monkeypatch -->
                <section id="mocks">
                    <h2>Mocks y Monkeypatch</h2>

                    <h3>¬øQu√© es un Mock?</h3>
                    <p>
                        Un <strong>mock</strong> es un objeto simulado que imita el comportamiento de un
                        objeto real. Nos permite:
                    </p>
                    <ul>
                        <li>Aislar el c√≥digo bajo prueba</li>
                        <li>Controlar respuestas de dependencias externas</li>
                        <li>Verificar interacciones (llamadas a m√©todos)</li>
                        <li>Simular errores y casos excepcionales</li>
                    </ul>

                    <h3>unittest.mock.Mock B√°sico</h3>
                    <pre><code class="language-python">from unittest.mock import Mock

# Crear un mock simple
mock_db = Mock()

# Configurar retorno
mock_db.obtener_usuario.return_value = Usuario(id=1, username="test")

# Usar el mock
usuario = mock_db.obtener_usuario(1)
assert usuario.username == "test"

# Verificar que se llam√≥
mock_db.obtener_usuario.assert_called_once_with(1)</code></pre>

                    <h3>Mock con Patch (Decorator)</h3>
                    <pre><code class="language-python">from unittest.mock import patch
from taskflow.services.usuario_service import UsuarioService

@patch('taskflow.services.usuario_service.UsuarioRepository')
def test_crear_usuario_con_mock(MockRepo):
    """Test que crea usuario usando repositorio mockeado."""
    # Configurar el mock
    mock_repo = MockRepo.return_value
    mock_repo.guardar.return_value = Usuario(id=1, username="newuser")

    # Usar el servicio
    service = UsuarioService(mock_repo)
    usuario = service.crear_usuario(username="newuser", email="new@example.com")

    # Verificaciones
    assert usuario.username == "newuser"
    mock_repo.guardar.assert_called_once()

@patch('taskflow.services.usuario_service.UsuarioRepository')
def test_error_al_crear_usuario(MockRepo):
    """Test que maneja error del repositorio."""
    # Configurar el mock para lanzar excepci√≥n
    mock_repo = MockRepo.return_value
    mock_repo.guardar.side_effect = Exception("Error de BD")

    # Usar el servicio y verificar excepci√≥n
    service = UsuarioService(mock_repo)

    with pytest.raises(Exception, match="Error de BD"):
        service.crear_usuario(username="user", email="user@example.com")</code></pre>

                    <h3>Monkeypatch: Modificar Comportamiento</h3>
                    <p>
                        <code>monkeypatch</code> es una fixture de pytest que permite modificar objetos
                        y atributos durante los tests.
                    </p>

                    <pre><code class="language-python">import pytest

def test_leer_archivo_usando_monkeypatch(monkeypatch, tmp_path):
    """Test que mockea la funci√≥n open()."""
    # Crear un archivo falso en memoria
    fake_content = "contenido falso del archivo"

    # Crear archivo temporal
    fake_file = tmp_path / "test.txt"
    fake_file.write_text(fake_content)

    # Monkeypatch para cambiar el comportamiento
    def mock_open(path, *args, **kwargs):
        if "test.txt" in str(path):
            return open(fake_file, *args, **kwargs)
        return open(path, *args, **kwargs)

    monkeypatch.setattr("builtins.open", mock_open)

    # Usar la funci√≥n que deber√≠a leer el archivo
    from taskfly.utils import leer_configuracion
    contenido = leer_configuracion("test.txt")

    assert contenido == fake_content</code></pre>

                    <h3>Ejemplo: Mockear Llamada HTTP</h3>
                    <pre><code class="language-python">import pytest
from unittest.mock import patch, Mock
from taskflow.services.external_api import obtener_usuario_desde_api

@patch('taskflow.services.external_api.requests.get')
def test_obtener_usuario_api(mock_get):
    """Test que mockea llamada HTTP."""
    # Configurar respuesta mockeada
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.json.return_value = {
        "id": 1,
        "username": "testuser",
        "email": "test@example.com"
    }
    mock_get.return_value = mock_response

    # Llamar a la funci√≥n
    usuario = obtener_usuario_desde_api(1)

    # Verificar resultado
    assert usuario.username == "testuser"
    assert mock_get.call_count == 1
    mock_get.assert_called_with("https://api.example.com/usuarios/1")</code></pre>

                    <h3>Mockear Repositorio de Archivos</h3>
                    <pre><code class="language-python">import pytest
from unittest.mock import Mock
from taskflow.services.proyecto_service import ProyectoService

def test_proyecto_service_con_repo_mockeado():
    """Test de servicio usando repositorio mockeado."""
    # Crear mock del repositorio
    mock_repo = Mock()

    # Configurar comportamiento del mock
    mock_repo.obtener_todos.return_value = [
        Proyecto(id=1, nombre="Proyecto 1"),
        Proyecto(id=2, nombre="Proyecto 2"),
    ]

    # Crear servicio con el mock
    service = ProyectoService(mock_repo)

    # Ejecutar m√©todo
    proyectos = service.obtener_todos_los_proyectos()

    # Verificaciones
    assert len(proyectos) == 2
    assert proyectos[0].nombre == "Proyecto 1"
    mock_repo.obtener_todos.assert_called_once()</code></pre>

                    <h3>Verificar Interacciones</h3>
                    <pre><code class="language-python">def test_verificar_llamadas_al_repo():
    """Test que verifica las llamadas al repositorio."""
    mock_repo = Mock()
    service = ProyectoService(mock_repo)

    # Ejecutar acci√≥n
    service.crear_proyecto("Nuevo Proyecto", usuario_id=1)

    # Verificar que se llam√≥ al repo con los argumentos correctos
    mock_repo.guardar.assert_called_once()

    # Verificar argumentos de la llamada
    args, kwargs = mock_repo.guardar.call_args
    proyecto_guardado = args[0]
    assert proyecto_guardado.nombre == "Nuevo Proyecto"
    assert proyecto_guardado.usuario_id == 1

    # Otra forma: verificar con assert_called_with
    # (requiere que el objeto tenga __eq__ implementado)
    mock_repo.guardar.assert_called_once()

    # Verificar n√∫mero de llamadas
    assert mock_repo.guardar.call_count == 1</code></pre>
                </section>

                <!-- Secci√≥n 6: Ejemplos Pr√°cticos -->
                <section id="ejemplos">
                    <h2>Ejemplos Pr√°cticos</h2>

                    <h3>Ejemplo 1: Tests Parametrizados de ProyectoService</h3>
                    <pre><code class="language-python"># tests/test_services/test_proyecto_service.py

import pytest
from unittest.mock import Mock
from taskflow.services.proyecto_service import ProyectoService
from taskflow.models.proyecto import Proyecto

class TestProyectoService:
    """Tests para ProyectoService usando fixtures y mocks."""

    @pytest.fixture
    def mock_repo(self):
        """Fixture que crea repositorio mockeado."""
        return Mock()

    @pytest.fixture
    def service(self, mock_repo):
        """Fixture que crea servicio con repo mockeado."""
        return ProyectoService(mock_repo)

    @pytest.mark.parametrize("nombre, usuario_id, valido", [
        ("Proyecto V√°lido", 1, True),
        ("P", 1, False),             # Nombre muy corto
        ("Proyecto Sin Usuario", None, False),  # Sin usuario
    ])
    def test_crear_proyecto(self, service, mock_repo, nombre, usuario_id, valido):
        """Test parametrizado de creaci√≥n de proyectos."""
        if valido:
            mock_repo.guardar.return_value = Proyecto(
                id=1,
                nombre=nombre,
                usuario_id=usuario_id
            )
            proyecto = service.crear_proyecto(nombre, usuario_id)
            assert proyecto.nombre == nombre
            mock_repo.guardar.assert_called_once()
        else:
            with pytest.raises(ValueError):
                service.crear_proyecto(nombre, usuario_id)

    def test_obtener_proyectos_de_usuario(self, service, mock_repo):
        """Test obtener proyectos de un usuario espec√≠fico."""
        # Configurar mock
        mock_repo.obtener_por_usuario.return_value = [
            Proyecto(id=1, nombre="Proyecto 1", usuario_id=1),
            Proyecto(id=2, nombre="Proyecto 2", usuario_id=1),
        ]

        # Ejecutar
        proyectos = service.obtener_proyectos_de_usuario(usuario_id=1)

        # Verificar
        assert len(proyectos) == 2
        mock_repo.obtener_por_usuario.assert_called_once_with(1)

    @pytest.mark.parametrize("estado", ["activo", "archivado", "completado"])
    def test_filtrar_proyectos_por_estado(self, service, mock_repo, estado):
        """Test parametrizado de filtrado por estado."""
        mock_repo.obtener_por_estado.return_value = [
            Proyecto(id=1, nombre=f"Proyecto {estado}", estado=estado)
        ]

        proyectos = service.obtener_proyectos_por_estado(estado)

        assert len(proyectos) >= 1
        assert all(p.estado == estado for p in proyectos)
        mock_repo.obtener_por_estado.assert_called_once_with(estado)</code></pre>

                    <h3>Ejemplo 2: Fixture Compleja para Integraci√≥n</h3>
                    <pre><code class="language-python"># tests/conftest.py

import pytest
from taskflow.models.usuario import Usuario
from taskflow.models.proyecto import Proyecto
from taskflow.models.tarea import Tarea

@pytest.fixture(scope="module")
def datos_bd_prueba():
    """Fixture que crea datos de prueba completos."""
    usuarios = [
        Usuario(id=1, username="admin", email="admin@example.com"),
        Usuario(id=2, username="user1", email="user1@example.com"),
        Usuario(id=3, username="user2", email="user2@example.com"),
    ]

    proyectos = [
        Proyecto(id=1, nombre="TaskFlow", usuario_id=1),
        Proyecto(id=2, nombre="Curso POO", usuario_id=2),
    ]

    tareas = [
        Tarea(id=1, titulo="Configurar", proyecto_id=1, asignado_a=1),
        Tarea(id=2, titulo="Implementar", proyecto_id=1, asignado_a=2),
        Tarea(id=3, titulo="Documentar", proyecto_id=2, asignado_a=3),
    ]

    return {
        "usuarios": usuarios,
        "proyectos": proyectos,
        "tareas": tareas,
    }

# tests/test_integration.py

def test_flujo_completo_usuario_proyecto_tarea(datos_bd_prueba):
    """Test de flujo completo usando fixture compleja."""
    usuarios = datos_bd_prueba["usuarios"]
    proyectos = datos_bd_prueba["proyectos"]
    tareas = datos_bd_prueba["tareas"]

    # Verificar que usuario admin tiene proyectos
    proyectos_admin = [p for p in proyectos if p.usuario_id == 1]
    assert len(proyectos_admin) == 1

    # Verificar que proyecto tiene tareas
    tareas_proyecto = [t for t in tareas if t.proyecto_id == 1]
    assert len(tareas_proyecto) == 2

    # Verificar asignaciones
    assert tareas_proyecto[0].asignado_a == 1
    assert tareas_proyecto[1].asignado_a == 2</code></pre>

                    <h3>Ejemplo 3: Tests con Context Manager</h3>
                    <pre><code class="language-python">@pytest.fixture
def session_db():
    """Fixture que crea una sesi√≥n de BD para tests."""
    from sqlalchemy import create_engine
    from sqlalchemy.orm import sessionmaker

    # Usar BD en memoria para tests
    engine = create_engine("sqlite:///:memory:")
    Session = sessionmaker(bind=engine)

    # Crear tablas
    from taskflow.models.base import Base
    Base.metadata.create_all(engine)

    session = Session()
    yield session

    # Cleanup
    session.close()
    engine.dispose()

def test_crud_con_session_db(session_db):
    """Test CRUD usando fixture de sesi√≥n."""
    from taskflow.models.usuario import Usuario

    # Create
    usuario = Usuario(username="test", email="test@example.com")
    session_db.add(usuario)
    session_db.commit()

    # Read
    from_db = session_db.query(Usuario).filter_by(username="test").first()
    assert from_db is not None
    assert from_db.username == "test"

    # Update
    from_db.nombre_completo = "Test User"
    session_db.commit()

    # Delete
    session_db.delete(from_db)
    session_db.commit()

    # Verificar que se elimin√≥
    assert session_db.query(Usuario).filter_by(username="test").first() is None</code></pre>
                </section>

                <!-- Secci√≥n 7: Buenas Pr√°cticas -->
                <section id="buenas-practicas">
                    <h2>Buenas Pr√°cticas</h2>

                    <h3>Organizaci√≥n de Tests</h3>
                    <pre><code class="language-text">tests/
‚îú‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ conftest.py              # Fixtures compartidas globalmente
‚îú‚îÄ‚îÄ test_models/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py          # Fixtures espec√≠ficas de modelos
‚îÇ   ‚îú‚îÄ‚îÄ test_usuario.py
‚îÇ   ‚îî‚îÄ‚îÄ test_proyecto.py
‚îú‚îÄ‚îÄ test_services/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py          # Fixtures espec√≠ficas de servicios
‚îÇ   ‚îú‚îÄ‚îÄ test_usuario_service.py
‚îÇ   ‚îî‚îÄ‚îÄ test_proyecto_service.py
‚îî‚îÄ‚îÄ test_api/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îî‚îÄ‚îÄ test_endpoints.py</code></pre>

                    <h3>Convenciones de Nombres</h3>
                    <ul>
                        <li><strong>Archivos:</strong> <code>test_*.py</code> o <code>*_test.py</code></li>
                        <li><strong>Clases:</strong> <code>Test*</code> (ej: <code>TestUsuario</code>)</li>
                        <li><strong>Funciones:</strong> <code>test_*</code></li>
                        <li><strong>Fixtures:</strong> Nombre descriptivo del recurso que proveen</li>
                    </ul>

                    <h3>DO's con Fixtures y Mocks</h3>
                    <ul>
                        <li><strong>Usa fixtures para setup compartido:</strong> Elimina duplicaci√≥n</li>
                        <li><strong>Usa el scope apropiado:</strong> No uses session si function basta</li>
                        <li><strong>Usa monkeypatch para modificar estado:</strong> M√°s claro que patch</li>
                        <li><strong>Verifica interacciones con mocks:</strong> assert_called, etc.</li>
                        <li><strong>Documenta fixtures complejas:</strong> Docstrings explican qu√© proveen</li>
                    </ul>

                    <h3>DON'T's con Fixtures y Mocks</h3>
                    <ul>
                        <li><strong>No sobreuses mocks:</strong> Solo para dependencias externas</li>
                        <li><strong>No mocks en exceso:</strong> Demasiados mocks = tests fr√°giles</li>
                        <li><strong>No uses fixtures globales excesivamente:</strong> Hacen tests interdependientes</li>
                        <li><strong>No ignores el teardow:</strong> Siempre limpia recursos</li>
                        <li><strong>No mockes el c√≥digo bajo prueba:</strong> Solo dependencias</li>
                    </ul>

                    <h3>Cu√°ndo NO Usar Mocks</h3>
                    <div class="alert-warning-custom">
                        <strong>Evita mocks cuando:</strong>
                        <ul>
                            <li>La dependencia es r√°pida y determinista (ej: funciones puras)</li>
                            <li>Quieres probar la integraci√≥n real</li>
                            <li>El mock se vuelve tan complejo como lo real</li>
                            <li>Est√°s probando una librer√≠a o framework (no sus dependencias)</li>
                        </ul>
                    </div>
                </section>

                <!-- Secci√≥n 8: Ejercicio Guido -->
                <section id="ejercicio">
                    <h2>Ejercicio Guido: Tests Parametrizados de ProyectoService</h2>

                    <h3>Objetivo</h3>
                    <p>
                        Crear tests parametrizados para la clase ProyectoService usando fixtures
                        y parametrizaci√≥n de pytest.
                    </p>

                    <h3>Instrucciones Paso a Paso</h3>

                    <h4>Paso 1: Crear Fixture de Repositorio (5 min)</h4>
                    <pre><code class="language-python"># tests/conftest.py

import pytest
from unittest.mock import Mock

@pytest.fixture
def mock_proyecto_repo():
    """Fixture que crea un repositorio de proyectos mockeado."""
    return Mock()</code></pre>

                    <h4>Paso 2: RED - Tests Parametrizados (10 min)</h4>
                    <pre><code class="language-python"># tests/test_services/test_proyecto_service.py

import pytest
from taskflow.services.proyecto_service import ProyectoService

@pytest.mark.parametrize("nombre, usuario_id, debe_crear", [
    ("Proyecto V√°lido", 1, True),
    ("P", 1, False),           # Nombre muy corto
    ("", 1, False),            # Nombre vac√≠o
    ("Proyecto", None, False), # Sin usuario
])
def test_crear_proyecto_parametrizado(mock_proyecto_repo, nombre, usuario_id, debe_crear):
    """Test parametrizado de creaci√≥n de proyectos."""
    # RED: Este test a√∫n no tiene implementaci√≥n
    service = ProyectoService(mock_proyecto_repo)

    if debe_crear:
        proyecto = service.crear_proyecto(nombre, usuario_id)
        assert proyecto.nombre == nombre
        mock_proyecto_repo.guardar.assert_called_once()
    else:
        with pytest.raises(ValueError):
            service.crear_proyecto(nombre, usuario_id)</code></pre>

                    <h4>Paso 3: GREEN - Implementar ProyectoService (10 min)</h4>
                    <pre><code class="language-python"># src/taskflow/services/proyecto_service.py

from taskflow.models.proyecto import Proyecto

class ProyectoService:
    """Servicio de l√≥gica de negocio para proyectos."""

    def __init__(self, repo):
        """Inicializar servicio con repositorio."""
        self.repo = repo

    def crear_proyecto(self, nombre, usuario_id):
        """
        Crear un nuevo proyecto.

        Args:
            nombre: Nombre del proyecto (m√≠nimo 3 caracteres)
            usuario_id: ID del usuario propietario

        Returns:
            Proyecto creado

        Raises:
            ValueError: Si los datos son inv√°lidos
        """
        # Validaciones
        if not nombre or len(nombre) < 3:
            raise ValueError("Nombre debe tener al menos 3 caracteres")

        if usuario_id is None:
            raise ValueError("Debe especificar usuario_id")

        # Crear proyecto
        proyecto = Proyecto(nombre=nombre, usuario_id=usuario_id)

        # Guardar usando repositorio
        return self.repo.guardar(proyecto)</code></pre>

                    <h4>Paso 4: GREEN - Configurar Mock (5 min)</h4>
                    <pre><code class="language-python"># Agregar al test

def test_crear_proyecto_parametrizado(mock_proyecto_repo, nombre, usuario_id, debe_crear):
    """Test parametrizado de creaci√≥n de proyectos."""
    # Configurar mock para retornar el proyecto que recibe
    def side_effect_guardar(proyecto):
        proyecto.id = 1  # Simular ID asignado por BD
        return proyecto

    mock_proyecto_repo.guardar.side_effect = side_effect_guardar

    service = ProyectoService(mock_proyecto_repo)

    if debe_crear:
        proyecto = service.crear_proyecto(nombre, usuario_id)
        assert proyecto.nombre == nombre
        assert proyecto.usuario_id == usuario_id
        mock_proyecto_repo.guardar.assert_called_once()
    else:
        with pytest.raises(ValueError):
            service.crear_proyecto(nombre, usuario_id)</code></pre>

                    <h4>Paso 5: M√°s Tests Parametrizados (10 min)</h4>
                    <pre><code class="language-python">@pytest.mark.parametrize("estado, cantidad_esperada", [
    ("activo", 3),
    ("archivado", 1),
    ("completado", 2),
])
def test_obtener_por_estado(mock_proyecto_repo, estado, cantidad_esperada):
    """Test parametrizado de obtenci√≥n por estado."""
    # Configurar mock
    from taskflow.models.proyecto import Proyecto

    mock_proyecto_repo.obtener_por_estado.return_value = [
        Proyecto(id=i, nombre=f"Proyecto {i}", estado=estado)
        for i in range(cantidad_esperada)
    ]

    service = ProyectoService(mock_proyecto_repo)
    proyectos = service.obtener_por_estado(estado)

    assert len(proyectos) == cantidad_esperada
    assert all(p.estado == estado for p in proyectos)
    mock_proyecto_repo.obtener_por_estado.assert_called_once_with(estado)</code></pre>

                    <h4>Paso 6: REFACTOR - Mejorar Organizaci√≥n (5 min)</h4>
                    <pre><code class="language-python"># tests/test_services/test_proyecto_service.py

class TestProyectoServiceCreacion:
    """Tests agrupados para creaci√≥n de proyectos."""

    @pytest.fixture
    def service(self, mock_proyecto_repo):
        """Fixture que crea servicio para esta clase."""
        return ProyectoService(mock_proyecto_repo)

    @pytest.mark.parametrize("nombre, usuario_id, debe_crear", [
        ("Proyecto V√°lido", 1, True),
        ("P", 1, False),
        ("", 1, False),
        ("Proyecto", None, False),
    ])
    def test_crear_proyecto(self, service, mock_proyecto_repo, nombre, usuario_id, debe_crear):
        """Test parametrizado dentro de clase de tests."""
        # ... implementaci√≥n

class TestProyectoServiceConsulta:
    """Tests agrupados para consultas."""

    @pytest.fixture
    def service(self, mock_proyecto_repo):
        return ProyectoService(mock_proyecto_repo)

    # ... tests de consulta</code></pre>

                    <h3>Conexi√≥n con TaskFlow</h3>
                    <p>
                        Los tests que est√°s creando para ProyectoService son la base de la capa de
                        servicios del proyecto TaskFlow. Estos tests garantizan que:
                    </p>
                    <ul>
                        <li>Las validaciones de negocio funcionan correctamente</li>
                        <li>El servicio interact√∫a correctamente con el repositorio</li>
                        <li>Podemos agregar m√°s servicios con el mismo patr√≥n</li>
                    </ul>

                    <h3>Resultado Esperado</h3>
                    <p>Al finalizar este ejercicio, tendr√°s:</p>
                    <ul>
                        <li>‚úÖ ProyectoService con tests parametrizados</li>
                        <li>‚úÖ Fixtures compartidas en conftest.py</li>
                        <li>‚úÖ Tests organizados en clases</li>
                        <li>‚úÖ Base para tests de otros servicios</li>
                    </ul>

                    <div class="alert-tip">
                        <strong>Tip:</strong> Ejecuta <code>pytest tests/test_services/test_proyecto_service.py -v</code>
                        para ver los nombres de los tests parametrizados generados.
                    </div>
                </section>

                <!-- Secci√≥n 9: Referencias -->
                <section id="referencias">
                    <h2>Para Profundizar</h2>
                    <ul>
                        <li>
                            <a href="https://docs.pytest.org/en/stable/explanation/fixtures.html" target="_blank">
                                pytest Fixtures - Documentaci√≥n Oficial
                            </a>
                        </li>
                        <li>
                            <a href="https://docs.pytest.org/en/stable/parametrize.html" target="_blank">
                                pytest Parametrizaci√≥n - Documentaci√≥n Oficial
                            </a>
                        </li>
                        <li>
                            <a href="https://docs.python.org/3/library/unittest.mock.html" target="_blank">
                                unittest.mock - Documentaci√≥n Python
                            </a>
                        </li>
                        <li>
                            <a href="https://realpython.com/pytest-python-testing/" target="_blank">
                                Real Python: A Practical Guide to pytest
                            </a>
                        </li>
                        <li>
                            <a href="https://www.youtube.com/watch?v=6E9tTWKsK_U" target="_blank">
                                Video: pytest Fixtures Tutorial
                            </a>
                        </li>
                    </ul>

                    <h3>Comandos √ötiles</h3>
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Comando</th>
                                <th>Descripci√≥n</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>pytest --fixtures</code></td>
                                <td>Listar todas las fixtures disponibles</td>
                            </tr>
                            <tr>
                                <td><code>pytest -v --tb=short</code></td>
                                <td>Output verbose con traceback corto</td>
                            </tr>
                            <tr>
                                <td><code>pytest -k "test_crear"</code></td>
                                <td>Ejecutar tests que contengan "test_crear"</td>
                            </tr>
                            <tr>
                                <td><code>pytest -x</code></td>
                                <td>Detenerse en el primer fallo</td>
                            </tr>
                            <tr>
                                <td><code>pytest --lf</code></td>
                                <td>Ejecutar solo los tests que fallaron la √∫ltima vez</td>
                            </tr>
                        </tbody>
                    </table>
                </section>
            </main>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2026 IF0100 - UNAULA | Todos los derechos reservados</p>
            <p>√öltima actualizaci√≥n: 2026-02-07</p>
        </div>
    </footer>

    <!-- Bootstrap 5 JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
            crossorigin="anonymous"></script>

    <!-- Prism.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>

    <!-- Prism.js Language Support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

    <!-- Highlight code on page load -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            Prism.highlightAll();
        });
    </script>
</body>
</html>
