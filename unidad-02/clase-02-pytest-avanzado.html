<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pytest Avanzado | IF0100</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <style>
        :root { --primary: #0d6efd; --success: #198754; --warning: #ffc107; --danger: #dc3545; --info: #0dcaf0; }
        header { background: linear-gradient(135deg, var(--primary) 0%, #0a58ca 100%); color: white; padding: 2rem 0; }
        .sidebar { background: #f8f9fa; border-radius: 8px; padding: 1.5rem; position: sticky; top: 2rem; }
        section { margin-bottom: 2rem; padding: 1.5rem; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        pre[class*="language-"] { border-radius: 6px; }
        .alert-tip { background: #d1e7dd; border-left: 4px solid var(--success); padding: 1rem; border-radius: 4px; }
        .alert-warning { background: #fff3cd; border-left: 4px solid var(--warning); padding: 1rem; border-radius: 4px; }
        .alert-note { background: #e7f3ff; border-left: 4px solid var(--info); padding: 1rem; border-radius: 4px; }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>IF0100 - Programación OO II</h1>
            <h2>Unidad 2: Técnicas de Desarrollo</h2>
            <h3>Clase 02: pytest Avanzado</h3>
            <p class="mt-2"><span class="badge bg-info">E2: Taller TDD/BDD - En 2 semanas</span></p>
        </div>
    </header>

    <div class="container mt-4">
        <div class="row">
            <aside class="col-lg-3">
                <nav class="sidebar">
                    <h5>Contenido</h5>
                    <ul class="list-unstyled">
                        <li><a href="#objetivos">Objetivos</a></li>
                        <li><a href="#fixtures">Fixtures</a></li>
                        <li><a href="#parametrizacion">Parametrización</a></li>
                        <li><a href="#mocks">Mocks</a></li>
                        <li><a href="#testclient">TestClient</a></li>
                        <li><a href="#ejercicio">Ejercicio</a></li>
                    </ul>
                </nav>
            </aside>

            <main class="col-lg-9">
                <section id="objetivos">
                    <h2 class="text-primary border-bottom pb-2">Objetivos de Aprendizaje</h2>
                    <ul>
                        <li>Crear fixtures para setup compartido</li>
                        <li>Usar scopes de fixtures (function, class, module)</li>
                        <li>Parametrizar tests con múltiples datos</li>
                        <li>Crear mocks para aislar dependencias</li>
                        <li>Testear APIs FastAPI con TestClient</li>
                    </ul>
                </section>

                <section id="fixtures">
                    <h2 class="text-primary border-bottom pb-2">Fixtures (25 min)</h2>
                    
                    <p>Una <strong>fixture</strong> prepara el entorno para un test. pytest la inyecta automáticamente.</p>

                    <h4>Fixture Básica</h4>
                    <pre><code class="language-python">import pytest

@pytest.fixture
def usuario():
    """Fixture que crea un usuario de prueba."""
    return {"id": 1, "username": "testuser", "email": "test@example.com"}

def test_usuario(usuario):  # pytest inyecta la fixture
    assert usuario["username"] == "testuser"</code></pre>

                    <h4>Fixture con Setup/Teardown</h4>
                    <pre><code class="language-python">@pytest.fixture
def archivo_temporal():
    """Crea archivo temporal y lo limpia después."""
    import tempfile, os
    
    fd, ruta = tempfile.mkstemp()
    with os.fdopen(fd, 'w') as f:
        f.write("contenido de prueba")
    
    yield ruta  # Entrega al test
    
    os.unlink(ruta)  # Cleanup después del test

def test_leer_archivo(archivo_temporal):
    with open(archivo_temporal, 'r') as f:
        assert f.read() == "contenido de prueba"</code></pre>

                    <h4>Scopes de Fixtures</h4>
                    <table class="table">
                        <tr><th>Scope</th><th>Cuándo se crea</th><th>Uso</th></tr>
                        <tr><td><code>function</code></td><td>Cada test</td><td>Default</td></tr>
                        <tr><td><code>class</code></td><td>Una vez por clase</td><td>Setup compartido</td></tr>
                        <tr><td><code>module</code></td><td>Una vez por módulo</td><td>Conexión BD</td></tr>
                        <tr><td><code>session</code></td><td>Una vez por sesión</td><td>Configuración global</td></tr>
                    </table>

                    <pre><code class="language-python">@pytest.fixture(scope="module")
def conexion_db():
    """Fixture de módulo: una conexión para todos los tests."""
    print("\n[SETUP] Conectando a BD...")
    db = {"conexion": "simulada", "datos": []}
    yield db
    print("\n[TEARDOWN] Cerrando conexión...")

def test_agregar(conexion_db):
    conexion_db["datos"].append("dato1")
    assert len(conexion_db["datos"]) == 1

def test_agregar_otro(conexion_db):
    conexion_db["datos"].append("dato2")
    assert len(conexion_db["datos"]) == 2  # dato1 sigue ahí</code></pre>

                    <h4>conftest.py: Fixtures Compartidas</h4>
                    <pre><code class="language-python"># tests/conftest.py
import pytest

@pytest.fixture
def usuario_base():
    """Fixture compartida por todos los tests."""
    return {"username": "base", "email": "base@example.com"}

# tests/test_usuario.py - usa la fixture automáticamente
def test_usa_fixture(usuario_base):
    assert usuario_base["username"] == "base"</code></pre>
                </section>

                <section id="parametrizacion">
                    <h2 class="text-primary border-bottom pb-2">Parametrización (15 min)</h2>
                    
                    <p>Ejecutar el mismo test con diferentes datos.</p>

                    <pre><code class="language-python">import pytest

@pytest.mark.parametrize("email, esperado", [
    ("usuario@example.com", True),
    ("user.name@example.com", True),
    ("invalido", False),
    ("@example.com", False),
    ("usuario@", False),
])
def test_validar_email(email, esperado):
    """Test parametrizado: 5 casos en 1 test."""
    from taskflow.utils import validar_email
    assert validar_email(email) == esperado</code></pre>

                    <p>pytest genera un test por cada caso:</p>
                    <pre><code class="language-bash">$ pytest -v
test_validar_email[usuario@example.com-True] PASSED
test_validar_email[invalido-False] PASSED
...</code></pre>

                    <h4>Múltiples Parámetros</h4>
                    <pre><code class="language-python">@pytest.mark.parametrize("username, valido", [
    ("abc", False),      # Muy corto
    ("valido", True),    # Válido
    ("ab", False),       # Muy corto
])
def test_validar_username(username, valido):
    assert len(username) >= 3 == valido</code></pre>
                </section>

                <section id="mocks">
                    <h2 class="text-primary border-bottom pb-2">Mocks (15 min)</h2>
                    
                    <p>Un <strong>mock</strong> simula objetos reales para aislar el código bajo prueba.</p>

                    <pre><code class="language-python">from unittest.mock import Mock, patch

# Mock simple
mock_db = Mock()
mock_db.obtener_usuario.return_value = {"id": 1, "username": "test"}
usuario = mock_db.obtener_usuario(1)
assert usuario["username"] == "test"
mock_db.obtener_usuario.assert_called_once_with(1)</code></pre>

                    <h4>Mock con Patch</h4>
                    <pre><code class="language-python">from unittest.mock import patch

@patch('taskflow.services.usuario_service.UsuarioRepository')
def test_crear_usuario(MockRepo):
    """Test que mockea el repositorio."""
    mock_repo = MockRepo.return_value
    mock_repo.guardar.return_value = {"id": 1, "username": "newuser"}
    
    service = UsuarioService(mock_repo)
    usuario = service.crear_usuario("newuser", "new@example.com")
    
    assert usuario["username"] == "newuser"
    mock_repo.guardar.assert_called_once()</code></pre>

                    <h4>Mock de Llamada HTTP</h4>
                    <pre><code class="language-python">@patch('requests.get')
def test_obtener_api(mock_get):
    """Mockea llamada HTTP."""
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.json.return_value = {"id": 1, "nombre": "Test"}
    mock_get.return_value = mock_response
    
    from taskflow.services import obtener_desde_api
    resultado = obtener_desde_api(1)
    
    assert resultado["nombre"] == "Test"</code></pre>
                </section>

                <section id="testclient">
                    <h2 class="text-primary border-bottom pb-2">TestClient FastAPI (10 min)</h2>
                    
                    <p><strong>TestClient</strong> permite testear APIs sin levantar servidor.</p>

                    <pre><code class="language-bash">pip install httpx pytest</code></pre>

                    <pre><code class="language-python">from fastapi.testclient import TestClient
from taskflow.main import app

client = TestClient(app)

def test_listar_tareas():
    response = client.get("/tareas")
    assert response.status_code == 200
    assert isinstance(response.json(), list)

def test_crear_tarea():
    response = client.post(
        "/tareas",
        json={"titulo": "Nueva tarea", "descripcion": "Test"}
    )
    assert response.status_code == 201
    data = response.json()
    assert data["titulo"] == "Nueva tarea"

def test_obtener_tarea_no_existe():
    response = client.get("/tareas/99999")
    assert response.status_code == 404</code></pre>

                    <h4>Fixture de TestClient</h4>
                    <pre><code class="language-python"># tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from taskflow.main import app

@pytest.fixture
def client():
    return TestClient(app)

# tests/test_api.py
def test_con_fixture(client):
    response = client.get("/")
    assert response.status_code == 200</code></pre>
                </section>

                <section id="ejercicio">
                    <h2 class="text-primary border-bottom pb-2">Ejercicio (5 min)</h2>
                    
                    <p>Crear tests para la API de tareas:</p>
                    <ol>
                        <li>Usar fixture de TestClient</li>
                        <li>Parametrizar test de validación</li>
                        <li>Mockear el repositorio</li>
                    </ol>

                    <pre><code class="language-python"># tests/test_tareas.py
import pytest
from fastapi.testclient import TestClient
from unittest.mock import Mock, patch

@pytest.fixture
def client():
    from taskflow.main import app
    return TestClient(app)

class TestTareasAPI:
    def test_crear_tarea(self, client):
        response = client.post("/tareas", json={"titulo": "Test"})
        assert response.status_code == 201
    
    @pytest.mark.parametrize("titulo, valido", [
        ("", False),      # Vacío
        ("A", True),      # Válido
        ("x" * 101, False),  # Muy largo
    ])
    def test_validar_titulo(self, client, titulo, valido):
        response = client.post("/tareas", json={"titulo": titulo})
        esperado = 201 if valido else 422
        assert response.status_code == esperado</code></pre>

                    <div class="alert-tip">
                        <strong>E2:</strong> Entregar tests con cobertura 80% usando fixtures y parametrización.
                    </div>
                </section>

                <section>
                    <h2 class="text-primary border-bottom pb-2">Resumen</h2>
                    <ul>
                        <li><strong>Fixtures:</strong> Preparan datos reutilizables</li>
                        <li><strong>Scopes:</strong> Controlan ciclo de vida</li>
                        <li><strong>Parametrize:</strong> Múltiples casos en un test</li>
                        <li><strong>Mocks:</strong> Aíslan dependencias externas</li>
                        <li><strong>TestClient:</strong> Testea APIs sin servidor</li>
                    </ul>
                </section>
            </main>
        </div>
    </div>

    <footer class="bg-light text-center py-3 mt-5">
        <div class="container">
            <p class="mb-0">&copy; 2026 IF0100 - UNAULA | <a href="clase-01-tdd-intro.html">← Anterior</a> | <a href="clase-03-bdd-intro.html">Siguiente: BDD →</a></p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>