<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clase 02 - Clases, Objetos y Encapsulamiento | IF0100 - POO II</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f7fa;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
            color: white;
            padding: 40px 20px;
            text-align: center;
            border-radius: 0 0 20px 20px;
            margin-bottom: 30px;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
        }

        header .meta {
            margin-top: 15px;
            font-size: 0.9em;
            opacity: 0.85;
        }

        nav {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 0;
            padding: 0;
            flex-wrap: wrap;
        }

        nav li {
            margin: 0;
        }

        nav a {
            display: block;
            padding: 10px 20px;
            color: #1e3a8a;
            text-decoration: none;
            border-radius: 5px;
            transition: background 0.3s;
            font-weight: 500;
        }

        nav a:hover {
            background: #e0e7ff;
        }

        section {
            background: white;
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h2 {
            color: #1e40af;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #3b82f6;
        }

        h3 {
            color: #1e3a8a;
            font-size: 1.5em;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        h4 {
            color: #3b82f6;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border: 1px solid #e5e7eb;
        }

        th {
            background: #1e40af;
            color: white;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background: #f9fafb;
        }

        pre {
            background: #1e293b;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
        }

        code {
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
        }

        pre code {
            color: inherit;
        }

        p code, li code {
            background: #e0e7ff;
            color: #1e40af;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .diagram {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            overflow-x: auto;
            border: 1px solid #e5e7eb;
        }

        figure {
            margin: 30px 0;
            text-align: center;
        }

        figure img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        figcaption {
            margin-top: 15px;
            font-style: italic;
            color: #64748b;
            font-size: 0.95em;
        }

        .comparison-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-table > div {
            background: #f8fafc;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .comparison-table h4 {
            color: #1e40af;
            margin-top: 0;
        }

        .highlight-box {
            background: linear-gradient(135deg, #dbeafe 0%, #e0e7ff 100%);
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #1e40af;
            margin: 20px 0;
        }

        .warning-box {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #f59e0b;
            margin: 20px 0;
        }

        .success-box {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #10b981;
            margin: 20px 0;
        }

        .note {
            background: #f0f4ff;
            border-left: 4px solid #3b82f6;
            padding: 10px 12px;
            border-radius: 8px;
            color: #52606d;
        }

        /* Syntax highlighting para C# */
        .token-keyword { color: #c792ea; font-weight: 600; }
        .token-type { color: #ffcb6b; }
        .token-string { color: #c3e88d; }
        .token-comment { color: #546e7a; font-style: italic; }
        .token-number { color: #f78c6c; }
        .token-operator { color: #89ddff; }

        /* Accessibility */
        abbr[title] { text-decoration: underline dotted; cursor: help; }

        ul, ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #1e40af;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            box-shadow: 0 4px 15px rgba(30, 64, 175, 0.4);
            transition: transform 0.3s;
        }

        .back-to-top:hover {
            transform: translateY(-5px);
        }

        footer {
            background: #1e293b;
            color: white;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .comparison-table {
                grid-template-columns: 1fr;
            }

            section {
                padding: 20px;
            }
        }

        /* Print styles */
        @media print {
            header, nav, footer { background: white !important; color: black !important; }
            a[href]:after { content: " (" attr(href) ")"; font-size: 0.8em; }
            pre, code { white-space: pre-wrap; }
        }
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #1e40af;
            color: #fff;
            padding: 8px 16px;
            text-decoration: none;
            z-index: 100;
            transition: top 0.3s;
        }
        .skip-link:focus {
            top: 0;
        }
    </style>
</head>
<body>
    <a href="#main" class="skip-link">Saltar al contenido</a>
    <header>
        <h1>Clases, Objetos y Encapsulamiento</h1>
        <div class="subtitle">IF0100 - Lenguaje de Programación OO II | 4 Semestre - Ingeniería Informática</div>
        <div class="meta">Duración: 90 minutos | Fecha: Semana 2</div>
    </header>

    <div class="container" id="main">
        <nav>
            <ul>
                <li><a href="#teoria">Teoría</a></li>
                <li><a href="#ejemplos">Ejemplos</a></li>
                <li><a href="#practica">Práctica / Laboratorio</a></li>
                <li><a href="#ejercicios">Ejercicios</a></li>
                <li><a href="#referencias">Referencias</a></li>
            </ul>
        </nav>

        <section id="teoria">
        <section id="objetivos">
            <h2>Objetivos y Agenda</h2>
            <table>
                <thead>
                    <tr>
                        <th>Objetivos</th>
                        <th>Agenda (90 min)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>1. Entender paradigma POO</td><td>15' Qué es POO?</td></tr>
                    <tr><td>2. Diferenciar clase vs objeto</td><td>20' Clase vs Objeto</td></tr>
                    <tr><td>3. Aplicar encapsulamiento</td><td>25' Encapsulamiento</td></tr>
                    <tr><td>4. Usar propiedades y constructores</td><td>20' Propiedades y Constructores</td></tr>
                    <tr><td>5. Comprender static vs instance</td><td>10' Static y Diferencias class/struct</td></tr>
                </tbody>
            </table>
        </section>

        <section id="poo">
            <h2>1. Programación Orientada a Objetos</h2>

            <h3>Qué es la POO?</h3>
            <p>La <strong><abbr title="Programación Orientada a Objetos: Paradigma de programación que organiza el software como objetos que contienen datos y código">POO</abbr></strong> (<strong>Programación Orientada a Objetos</strong>) es un <strong>paradigma</strong> de programación (estilo o enfoque para escribir código) que se basa en el concepto de "objetos", que pueden contener datos y código:</p>
            <ul>
                <li><strong>Datos:</strong> Atributos o propiedades (campos)</li>
                <li><strong>Código:</strong> Comportamientos o métodos (funciones)</li>
            </ul>
            <p><strong>¿Por qué usar POO?</strong> Permite organizar código complejo de manera modular, reutilizable y más fácil de mantener que la programación procedural tradicional.</p>

            <h3>Procedural vs POO</h3>
            <table>
                <thead>
                    <tr>
                        <th>Aspecto</th>
                        <th>Programación Procedural</th>
                        <th>Programación Orientada a Objetos</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><strong>Unidad básica</strong></td><td>Funciones/procedimientos</td><td>Clases/objetos</td></tr>
                    <tr><td><strong>Datos</strong></td><td>Separados de funciones</td><td>Unidos con métodos</td></tr>
                    <tr><td><strong>Organización</strong></td><td>Procedimientos que actúan sobre datos</td><td>Objetos que encapsulan datos y comportamiento</td></tr>
                    <tr><td><strong>Mantenimiento</strong></td><td>Difícil (código acoplado)</td><td>Modular (código desacoplado)</td></tr>
                    <tr><td><strong>Escalabilidad</strong></td><td>Limitada</td><td>Fácil de extender</td></tr>
                    <tr><td><strong>Reutilización</strong></td><td>Baja</td><td>Alta (herencia, composición)</td></tr>
                </tbody>
            </table>

            <h3>Ejemplo Comparativo</h3>
            <div class="comparison-table">
                <div>
                    <h4>Enfoque Procedural (C)</h4>
                    <pre><code class="language-c">// Datos separados
struct Estudiante {
    char nombre[100];
    int edad;
    double promedio;
};

// Funciones separadas
void imprimir_estudiante(struct Estudiante* e) {
    printf("Nombre: %s\n", e->nombre);
}

double calcular_promedio(struct Estudiante* e) {
    return e->promedio;
}</code></pre>
                </div>
                <div>
                    <h4>Enfoque POO (C#)</h4>
                    <pre><code class="language-csharp">// Datos y comportamiento UNIDOS
public class Estudiante
{
    // Datos (propiedades)
    public string Nombre { get; set; }
    public int Edad { get; set; }
    public double Promedio { get; set; }

    // Comportamiento (metodos)
    public void Imprimir() =>
        Console.WriteLine($"Nombre: {Nombre}");

    public bool Aprobado() =>
        Promedio >= 3.0;
}</code></pre>
                </div>
            </div>

            <div class="success-box">
                <h4>Ventajas de POO</h4>
                <ul>
                    <li><strong>Modularidad:</strong> Código organizado en unidades lógicas (clases)</li>
                    <li><strong>Reutilización:</strong> Código reutilizable mediante herencia y composición</li>
                    <li><strong>Mantenibilidad:</strong> Cambios localizados en clases específicas</li>
                    <li><strong>Extensibilidad:</strong> Fácil agregar nuevas funcionalidades</li>
                    <li><strong>Abstracción:</strong> Oculta complejidad, expone solo lo necesario</li>
                    <li><strong>Modelado del mundo real:</strong> Objetos representan entidades del dominio</li>
                </ul>
            </div>
        </section>

        <section id="pilares">
            <h2>Los Tres Pilares de la POO</h2>

            <div class="diagram">
              <figure>
                <svg width="100%" viewBox="0 0 720 240" preserveAspectRatio="xMidYMid meet" role="img" aria-labelledby="poo-pillars-3">
                  <title id="poo-pillars-3">Pilares de la POO</title>
                  <style>
                    .pill{fill:#0b2d6b;rx:8}
                    .h{font:700 13px Arial, sans-serif; fill:#fff}
                    .s{font:12px Arial, sans-serif; fill:#e6eefc}
                  </style>
                  <rect x="40" y="36" width="200" height="168" rx="10" fill="#0b2d6b"/>
                  <text x="140" y="66" text-anchor="middle" class="h">ENCAPSULAMIENTO</text>
                  <text x="140" y="96" text-anchor="middle" class="s">Ocultar datos internos</text>

                  <rect x="260" y="36" width="200" height="168" rx="10" fill="#0b2d6b"/>
                  <text x="360" y="66" text-anchor="middle" class="h">HERENCIA</text>
                  <text x="360" y="96" text-anchor="middle" class="s">Reutilizar código</text>

                  <rect x="480" y="36" width="200" height="168" rx="10" fill="#0b2d6b"/>
                  <text x="580" y="66" text-anchor="middle" class="h">POLIMORFISMO</text>
                  <text x="580" y="96" text-anchor="middle" class="s">Una interfaz, múltiples formas</text>

                </svg>
                <figcaption>Pilares fundamentales: encapsulamiento (hoy), herencia y polimorfismo (próxima clase).</figcaption>
              </figure>
            </div>

            <div class="highlight-box">
                <h4>1. Encapsulamiento (Clase 2 - Hoy)</h4>
                <p>Ocultar los detalles internos de un objeto y exponer solo lo necesario a través de una interfaz pública.</p>
                <p><strong>Beneficios:</strong> Protección de datos, control de modificaciones, flexibilidad interna.</p>
            </div>

            <div class="warning-box">
                <h4>2. Herencia (Clase 3 - Próxima)</h4>
                <p>Crear nuevas clases basadas en clases existentes, reutilizando codigo y extendiendo funcionalidad.</p>
                <p><strong>Beneficios:</strong> Reutilización de código, jerarquías lógicas, extensibilidad.</p>
            </div>

            <div class="warning-box">
                <h4>3. Polimorfismo (Clase 3 - Próxima)</h4>
                <p>Capacidad de objetos de diferentes tipos responder al mismo mensaje de diferentes formas.</p>
                <p><strong>Beneficios:</strong> Codigo flexible, tratamiento uniforme, facil agregar nuevos tipos.</p>
            </div>
        </section>

        <section id="clase-vs-objeto">
            <h2>Clase vs Objeto</h2>

            <figure>
                <img src="../assets/infografias/clase-02-clase-vs-objeto.png" alt="Infografia: Clase vs Objeto - La diferencia entre plantilla y instancia">
                <figcaption>Comparación visual entre clases (plantillas abstractas que definen estructura y comportamiento) y objetos (instancias concretas que ocupan memoria con datos específicos), ilustrando el concepto fundamental de la POO.</figcaption>
            </figure>

            <h3>CLASE = Molde / Plantilla / Definición</h3>
            <p>Una clase es una <strong>definicion</strong> o <strong>plantilla</strong> para crear objetos. Es abstracta y no ocupa memoria por si misma.</p>
            <ul>
                <li>Define estructura (qué datos tendrá)</li>
                <li>Especifica comportamiento (qué podrá hacer)</li>
                <li>NO ocupa memoria en tiempo de ejecución</li>
                <li>Es el "tipo" o "categoria"</li>
                <li>Escrita una vez, usada muchas veces</li>
            </ul>

            <h3>OBJETO = Instancia / Ejemplar / Creacion Concreta</h3>
            <p>Un objeto es una <strong>instancia concreta</strong> de una clase. Ocupa memoria y tiene valores especificos.</p>
            <ul>
                <li>Creado a partir de una clase con <code>new</code></li>
                <li>Ocupa memoria (heap para reference types)</li>
                <li>Tiene valores especificos para sus atributos</li>
                <li>Puede ejecutar sus metodos</li>
                <li>Cada objeto es independiente</li>
            </ul>

            <h3>Comparativa Detallada</h3>
            <table>
                <thead>
                    <tr>
                        <th>Aspecto</th>
                        <th>Clase (Molde)</th>
                        <th>Objeto (Instancia)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><strong>Naturaleza</strong></td><td>Abstracta (definicion)</td><td>Concreta (ejecucion)</td></tr>
                    <tr><td><strong>Memoria</strong></td><td>NO ocupa (metadata)</td><td>SI ocupa (heap)</td></tr>
                    <tr><td><strong>Cantidad</strong></td><td>Una definicion</td><td>Multiples instancias</td></tr>
                    <tr><td><strong>Valores</strong></td><td>Define QUÉ atributos tendrá</td><td>TIENE valores específicos</td></tr>
                    <tr><td><strong>Declaracion</strong></td><td><code>class Galleta { ... }</code></td><td><code>new Galleta()</code></td></tr>
                    <tr><td><strong>Relación</strong></td><td>Es un "tipo de dato"</td><td>Es una "variable" de ese tipo</td></tr>
                    <tr><td><strong>Analogia</strong></td><td>Receta de cocina</td><td>Galleta horneada</td></tr>
                    <tr><td><strong>Analogia</strong></td><td>Plano de arquitectura</td><td>Casa construida</td></tr>
                </tbody>
            </table>

            <h3>Analogía: Galletas</h3>
            <div class="comparison-table">
                <div>
                    <h4>CLASE = Receta de galletas</h4>
                    <ul>
                        <li>Define ingredientes: harina, azucar, chocolate</li>
                        <li>Define procedimiento: mezclar, hornear, enfriar</li>
                        <li>NO se puede comer (es abstracta)</li>
                    </ul>
                </div>
                <div>
                    <h4>OBJETO = Galleta horneada</h4>
                    <ul>
                        <li>Tiene cantidades especificas de ingredientes</li>
                        <li>Se puede comer (es concreta)</li>
                        <li>Cada galleta es unica pero sigue la receta</li>
                    </ul>
                </div>
            </div>

            <h3>Ejemplo de Código</h3>
            <pre><code class="language-csharp">// ============================================
// CLASE: Definicion (plantilla)
// ============================================
public class Estudiante
{
    // Campos (atributos)
    public string Nombre;
    public string Codigo;
    public int Edad;
    public double Promedio;

    // Metodos (comportamiento)
    public void MostrarInfo()
    {
        Console.WriteLine($"Nombre: {Nombre}");
        Console.WriteLine($"Codigo: {Codigo}");
        Console.WriteLine($"Edad: {Edad}");
        Console.WriteLine($"Promedio: {Promedio}");
    }

    public bool Aprobado() => Promedio >= 3.0;
}

// ============================================
// OBJETOS: Instancias (creaciones concretas)
// ============================================
class Program
{
    static void Main()
    {
        // Crear PRIMER objeto (instancia)
        Estudiante est1 = new Estudiante();
        est1.Nombre = "Maria Lopez";
        est1.Codigo = "2024001";
        est1.Edad = 20;
        est1.Promedio = 4.2;

        // Crear SEGUNDO objeto (independiente)
        Estudiante est2 = new Estudiante();
        est2.Nombre = "Carlos Ruiz";
        est2.Codigo = "2024002";
        est2.Edad = 22;
        est2.Promedio = 2.8;

        // Cada objeto es independiente
        est1.MostrarInfo();
        Console.WriteLine();
        est2.MostrarInfo();
    }
}</code></pre>
        </section>

        <section id="memoria">
            <h2>Representación en Memoria</h2>

            <h3>STACK vs HEAP</h3>
            <p>En C#, los objetos (reference types) se almacenan en dos areas de memoria:</p>

            <h4>STACK (Pila)</h4>
            <p>Memoria organizada como <abbr title="LIFO: Last In, First Out - El último elemento en entrar es el primero en salir, como una pila de platos">LIFO</abbr> (Last In, First Out), ideal para variables locales y referencias.</p>
            <ul>
                <li>Almacena <strong>variables locales</strong> y <strong>referencias</strong> a objetos</li>
                <li>Crece y decrece rápidamente</li>
                <li>Limpieza automática al salir del método</li>
                <li>Cada hilo tiene su propio stack</li>
                <li>Almacena directamente los <strong>value types</strong> (int, double, bool, struct)</li>
            </ul>

            <h4>HEAP (Montículo)</h4>
            <p>Memoria dinámica para objetos más grandes y con vida útil variable.</p>
            <ul>
                <li>Almacena <strong>objetos reales</strong> (instancias de clases)</li>
                <li>Memoria más grande pero más lenta de gestionar</li>
                <li>Limpieza automática por el <strong><abbr title="Garbage Collector: Mecanismo de .NET que libera automáticamente memoria de objetos que ya no se usan">GC</abbr></strong> (Garbage Collector)</li>
                <li>Compartido por todos los hilos</li>
                <li>Almacena los <strong>reference types</strong> (class, string, array)</li>
            </ul>
            <div class="note">Nota: El GC es un componente del CLR que periódicamente escanea el heap buscando objetos sin referencias y libera su memoria automáticamente.</div>

            <h3>Visualización de Memoria</h3>
            <figure>
              <svg width="100%" viewBox="0 0 820 260" preserveAspectRatio="xMidYMid meet" role="img" aria-labelledby="memoriaTitle">
                <title id="memoriaTitle">Representación de Stack y Heap en memoria</title>
                <style>
                  .sbox{fill:#eef2ff;stroke:#dbeafe;rx:8}
                  .hbox{fill:#fff1f2;stroke:#fbcfce;rx:8}
                  .t{font:700 12px Arial, sans-serif;fill:#0b2d6b}
                  .mut{font:12px Arial, sans-serif;fill:#475569}
                </style>
                <rect x="20" y="24" width="300" height="172" rx="8" fill="#eef2ff" stroke="#dbeafe"/>
                <text x="170" y="44" text-anchor="middle" class="t">STACK (Referencias)</text>
                <rect x="380" y="24" width="400" height="172" rx="8" fill="#fff1f2" stroke="#fbcfce"/>
                <text x="580" y="44" text-anchor="middle" class="t">HEAP (Objetos reales)</text>

                <rect x="40" y="68" width="120" height="36" rx="6" fill="#fff" stroke="#cfe2ff"/>
                <text x="100" y="90" text-anchor="middle" class="mut">est1
0x7F3A...</text>
                <rect x="40" y="116" width="120" height="36" rx="6" fill="#fff" stroke="#cfe2ff"/>
                <text x="100" y="138" text-anchor="middle" class="mut">est2
0x8B2C...</text>

                <rect x="420" y="72" width="320" height="112" rx="8" fill="#fff" stroke="#ffd6e0"/>
                <text x="580" y="96" text-anchor="middle" class="mut">Obj Estudiante
Nombre: “María”
Cód: “2024001”
Edad: 20 • Prom: 4.2</text>

              </svg>
              <figcaption>Variables en stack contienen referencias que apuntan a objetos en heap; ejemplo de dos referencias (`est1`, `est2`) apuntando a objetos en el heap.</figcaption>
            </figure>

            <h3>Flujo de Creación de un Objeto</h3>
            <pre><code class="language-csharp">// Paso 1: Declaracion (stack - variable de referencia)
Estudiante est1;  // stack: est1 = null

// Paso 2: Instanciacion (heap - objeto creado)
est1 = new Estudiante();  // heap: new Estudiante object

// Paso 3: Asignacion de valores
est1.Nombre = "Maria";  // heap: Nombre = "Maria"
est1.Edad = 20;         // heap: Edad = 20</code></pre>

            <div class="warning-box">
                <h4>Puntos Clave</h4>
                <ul>
                    <li>La variable en el STACK contiene una <strong>direccion de memoria</strong> (referencia) al objeto en el HEAP</li>
                    <li><strong>Multiples variables pueden referenciar el mismo objeto</strong>:
                        <pre><code class="language-csharp">Estudiante est1 = new Estudiante { Nombre = "Maria" };
Estudiante est2 = est1;  // Ambos referencian el MISMO objeto
est2.Nombre = "Carlos";   // est1.Nombre tambien cambia</code></pre>
                    </li>
                    <li>Cuando una variable sale del scope, la referencia en el stack se elimina, pero el objeto en el heap permanece hasta que el GC lo reclama</li>
                </ul>
            </div>
        </section>

        <section id="encapsulamiento">
            <h2>Encapsulamiento</h2>

            <figure>
                <img src="../assets/infografias/clase-02-encapsulamiento.png" alt="Infografia: Encapsulamiento - Proteccion de datos y exposicion de comportamiento">
                <figcaption>Principio de encapsulamiento en POO: protección de datos internos mediante modificadores de acceso, exponiendo solo métodos y propiedades públicas para interactuar de forma controlada con el objeto.</figcaption>
            </figure>

            <h3>Qué es Encapsulamiento?</h3>
            <p><strong>Encapsulamiento</strong> es el principio de ocultar los detalles internos de implementación de un objeto y exponer solo lo necesario a través de una interfaz pública.</p>
            <p><em>Metáfora: Un coche tiene un encapsulamiento - tu solo interactuas con el volante, pedales y botones. No necesitas saber como funciona el motor internamente.</em></p>

            <h3>Por qué es IMPORTANTE?</h3>
            <table>
                <thead>
                    <tr>
                        <th>Problema sin encapsulamiento</th>
                        <th>Solucion con encapsulamiento</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>Datos expuestos pueden modificarse a valores invalidos</td><td>Validacion controlada</td></tr>
                    <tr><td>Dificil mantener (cambios afectan a todos)</td><td>Cambios localizados</td></tr>
                    <tr><td>Acoplamiento alto (dependencias ocultas)</td><td>Bajo acoplamiento</td></tr>
                    <tr><td>Codigo fragil (se rompe facil)</td><td>Codigo robusto</td></tr>
                </tbody>
            </table>

            <h3>SIN Encapsulamiento (Frágil)</h3>
            <pre><code class="language-csharp">public class CuentaBancaria
{
    // Campos PUBLICOS = peligro
    public double saldo;
    public string titular;
}

// Uso problematico
var cuenta = new CuentaBancaria();
cuenta.saldo = -1000;  // Valido pero INCORRECTO
cuenta.titular = "";   // Nombre vacio permitido</code></pre>

            <div class="warning-box">
                <h4>Problemas sin encapsulamiento:</h4>
                <ul>
                    <li>Sin validacion de datos</li>
                    <li>Cualquiera puede modificar</li>
                    <li>Dificil rastrear quien modifico</li>
                    <li>No se pueden agregar reglas de negocio</li>
                </ul>
            </div>

            <h3>CON Encapsulamiento (Robusto)</h3>
            <pre><code class="language-csharp">public class CuentaBancaria
{
    // Campos PRIVADOS = protegidos
    private double _saldo;
    private string _titular;

    // Propiedad con validacion
    public string Titular
    {
        get => _titular;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("El titular no puede estar vacio");
            _titular = value;
        }
    }

    // Metodos controlados
    public void Depositar(double monto)
    {
        if (monto <= 0)
            throw new ArgumentException("El monto debe ser positivo");
        _saldo += monto;
    }

    public void Retirar(double monto)
    {
        if (monto <= 0)
            throw new ArgumentException("El monto debe ser positivo");
        if (monto > _saldo)
            throw new InvalidOperationException("Saldo insuficiente");
        _saldo -= monto;
    }

    public double Saldo => _saldo;  // Solo lectura
}</code></pre>

            <div class="success-box">
                <h4>Beneficios con encapsulamiento:</h4>
                <ul>
                    <li>Validacion de datos en entrada</li>
                    <li>Control sobre modificaciones</li>
                    <li>Facil agregar logica de negocio</li>
                    <li>Proteccion del estado interno</li>
                </ul>
            </div>

            <h3>Principio de Minima Exposicion</h3>
            <div class="highlight-box">
                <h4>Regla de Oro</h4>
                <p><strong>Expón solo lo que es necesario para usar la clase. Oculta todo lo demás.</strong></p>
                <pre><code class="language-csharp">public class Estudiante
{
    // PUBLICO: Parte de la API externa
    public string Nombre { get; set; }
    public int Edad { get; set; }

    // PRIVADO: Implementacion interna
    private double _promedioInterno;
    private void _calcularPromedioInterno() { ... }

    // PUBLICO: Expone resultado calculado (no los detalles)
    public double Promedio => _promedioInterno;
}</code></pre>
            </div>
        </section>

        <section id="modificadores">
            <h2>Modificadores de Acceso</h2>

            <h3>Tabla de Modificadores en C#</h3>
            <table>
                <thead>
                    <tr>
                        <th>Modificador</th>
                        <th>Quien accede?</th>
                        <th>Descripcion</th>
                        <th>Uso tipico</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><code>public</code></td><td>TODOS</td><td>Accesible desde cualquier lugar</td><td>API publica de la clase</td></tr>
                    <tr><td><code>private</code></td><td>Solo la clase</td><td>Solo accesible dentro de la clase</td><td>Campos internos, metodos auxiliares</td></tr>
                    <tr><td><code>protected</code></td><td>Clase + hijas</td><td>Accesible en la clase y sus derivadas</td><td>Miembros para herencia</td></tr>
                    <tr><td><code>internal</code></td><td>Mismo proyecto</td><td>Accesible solo en el mismo assembly</td><td>Clases auxiliares del proyecto</td></tr>
                    <tr><td><code>protected internal</code></td><td>Misma clase + hijas + mismo proyecto</td><td>Combinación de protected y internal</td><td>Miembros especializados</td></tr>
                    <tr><td><code>private protected</code></td><td>Clase + hijas (mismo proyecto)</td><td>Solo hijas en el mismo proyecto</td><td>Herencia interna</td></tr>
                </tbody>
            </table>

            <h3>Reglas de Oro</h3>
            <ol>
                <li><strong>Campos SIEMPRE privados</strong> (convención <code>_camelCase</code>)</li>
                <li><strong>Propiedades publicas</strong> para acceso controlado</li>
                <li><strong>Metodos privados</strong> para logica interna</li>
                <li><strong>Minimizar <code>public</code></strong> - expón solo lo necesario</li>
            </ol>

            <h3>Ejemplo Completo</h3>
            <pre><code class="language-csharp">public class CuentaBancaria
{
    // PRIVADOS: Solo uso interno
    private double _saldo;
    private readonly string _numeroCuenta;

    // PUBLICOS: API externa
    public string Titular { get; set; }

    // SOLO LECTURA: No se puede modificar despues de crear
    public string NumeroCuenta => _numeroCuenta;

    // PROPORCIONAL: Saldo expuesto pero sin modificacion directa
    public double Saldo => _saldo;

    // Constructor
    public CuentaBancaria(string titular, string numeroCuenta, double saldoInicial)
    {
        Titular = titular;
        _numeroCuenta = numeroCuenta;
        _saldo = saldoInicial;
    }

    // PUBLICO: Comportamiento controlado
    public void Depositar(double monto)
    {
        _validarMontoPositivo(monto);
        _saldo += monto;
    }

    // PRIVADO: Validacion interna (reutilizable)
    private void _validarMontoPositivo(double monto)
    {
        if (monto <= 0)
            throw new ArgumentException("El monto debe ser positivo");
    }
}</code></pre>
        </section>

        <section id="propiedades">
            <h2>Propiedades</h2>

            <h3>Qué son las Propiedades?</h3>
            <p>Las propiedades son <strong><abbr title="Syntactic sugar: Sintaxis más legible que el compilador convierte a código más complejo internamente">syntactic sugar</abbr></strong> (azúcar sintáctico) para encapsulamiento. Parecen campos pero son métodos (<code>get</code> y <code>set</code>) disfrazados que el compilador traduce a llamadas de métodos.</p>
            <p><strong>¿Por qué usarlas?</strong> Código más limpio y natural que métodos getter/setter tradicionales, con la misma capacidad de validación y control.</p>

            <h3>TRADICIONAL (Java-style) - Verboso</h3>
            <pre><code class="language-csharp">public class Persona
{
    private string _nombre;

    // Metodo getter
    public string GetNombre()
    {
        return _nombre;
    }

    // Metodo setter
    public void SetNombre(string valor)
    {
        _nombre = valor;
    }
}

// Uso verboso
var p = new Persona();
p.SetNombre("Maria");
string n = p.GetNombre();</code></pre>

            <h3>MODERNO C# - Propiedades</h3>
            <pre><code class="language-csharp">public class Persona
{
    private string _nombre;

    // Propiedad con get y set
    public string Nombre
    {
        get { return _nombre; }
        set { _nombre = value; }
    }
}

// Uso natural
var p = new Persona();
p.Nombre = "Maria";      // Usa 'set'
string n = p.Nombre;     // Usa 'get'</code></pre>

            <h3>Tipos de Propiedades</h3>
            <table>
                <thead>
                    <tr>
                        <th>Tipo</th>
                        <th>Sintaxis</th>
                        <th>Cuando usar</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>Autoimplementada</td><td><code>{ get; set; }</code></td><td>Sin validacion, simple</td></tr>
                    <tr><td>Con backing field</td><td>get/set con logica</td><td>Con validacion</td></tr>
                    <tr><td>Solo lectura</td><td><code>{ get; }</code></td><td>Calculado o inmutable</td></tr>
                    <tr><td>Init-only</td><td><code>{ get; init; }</code></td><td>Solo en constructor</td></tr>
                    <tr><td>Expresion bodied</td><td><code>=> valor</code></td><td>Propiedades calculadas</td></tr>
                </tbody>
            </table>

            <h3>Ejemplos Completos</h3>
            <p><strong>Backing field:</strong> Es el campo privado (<code>_campo</code>) que almacena el valor real de una propiedad. Se usa cuando necesitas lógica en get/set.</p>
            <pre><code class="language-csharp">public class Estudiante
{
    // 1. AUTOIMPLEMENTADA (sin validacion)
    public string Nombre { get; set; }
    public int Edad { get; set; }

    // 2. CON VALIDACION (usa backing field)
    private double _promedio;  // Este es el "backing field"
    public double Promedio
    {
        get => _promedio;
        set
        {
            if (value < 0.0 || value > 5.0)
                throw new ArgumentOutOfRangeException("Promedio", "Debe estar entre 0 y 5");
            _promedio = value;
        }
    }

    // 3. SOLO LECTURA (calculada)
    public bool Aprobado => Promedio >= 3.0;

    // 4. INIT-ONLY (solo se asigna en constructor o inicializador)
    public string Matricula { get; init; }

    // 5. CON VALOR DEFAULT
    public string Carrera { get; set; } = "Sin carrera";

    // 6. EXPRESION BODIED (C# 7+)
    public string InfoCompleta => $"{Nombre} ({Edad} años) - {Carrera}";
}</code></pre>
            <div class="note">Nota: Una propiedad es <strong>inmutable</strong> cuando su valor no puede cambiar después de la creación del objeto. Se logra con <code>{ get; }</code> (solo lectura), <code>{ get; init; }</code> (solo en constructor), o <code>readonly</code> en campos.</div>
        </section>

        <section id="constructores">
            <h2>Constructores</h2>

            <h3>Qué es un Constructor?</h3>
            <p>Un constructor es un <strong>método especial</strong> que se ejecuta automáticamente al crear una instancia de una clase con <code>new</code>.</p>

            <p><strong>Proposito:</strong></p>
            <ul>
                <li>Inicializar valores predeterminados</li>
                <li>Recibir parámetros obligatorios</li>
                <li>Validar estado inicial</li>
                <li>Establecer invariantes de clase</li>
            </ul>

            <h3>Tipos de Constructores</h3>
            <table>
                <thead>
                    <tr>
                        <th>Tipo</th>
                        <th>Sintaxis</th>
                        <th>Ejemplo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>Default</td><td>sin parametros</td><td><code>new Estudiante()</code></td></tr>
                    <tr><td>Parametrizado</td><td>con parámetros</td><td><code>new Estudiante("Maria", 20)</code></td></tr>
                    <tr><td>Object Initializer</td><td>sintaxis <code>{ }</code></td><td><code>new Estudiante { Nombre = "Maria" }</code></td></tr>
                    <tr><td>Primary (C# 12)</td><td>parámetros en clase</td><td><code>public class Estudiante(string nombre)</code></td></tr>
                </tbody>
            </table>

            <h3>Ejemplo Completo</h3>
            <pre><code class="language-csharp">public class Estudiante
{
    public string Nombre { get; set; }
    public string Codigo { get; set; }
    public int Edad { get; set; }
    public double Promedio { get; set; }

    // 1. CONSTRUCTOR DEFAULT
    public Estudiante()
    {
        Nombre = "Sin nombre";
        Codigo = "0000000";
        Edad = 18;
        Promedio = 0.0;
    }

    // 2. CONSTRUCTOR PARAMETRIZADO
    public Estudiante(string nombre, string codigo, int edad)
    {
        if (string.IsNullOrWhiteSpace(nombre))
            throw new ArgumentException("Nombre requerido");
        if (edad < 16 || edad > 100)
            throw new ArgumentOutOfRangeException("Edad");

        Nombre = nombre;
        Codigo = codigo;
        Edad = edad;
        Promedio = 0.0;
    }

    // 3. CONSTRUCTOR CON ENCADENAMIENTO (this)
    public Estudiante(string nombre, string codigo)
        : this(nombre, codigo, 18)  // Llama al constructor de 3 params
    {
        // Edad ya se inicializo en 18
    }
}

// USO
var e1 = new Estudiante();                              // Default
var e2 = new Estudiante("Maria", "2024001", 20);       // Parametrizado
var e3 = new Estudiante("Carlos", "2024002");          // Encadenado (edad=18)</code></pre>

            <h3>Orden de Ejecucion con <code>this</code></h3>
            <figure>
              <svg width="100%" viewBox="0 0 820 260" preserveAspectRatio="xMidYMid meet" role="img" aria-labelledby="chainTitle">
                <title id="chainTitle">Encadenamiento de constructores en C#</title>
                <style>
                  .box{fill:#fff;stroke:#dbeafe;rx:8}
                  .h{font:700 13px Arial, sans-serif; fill:#0b2d6b}
                  .s{font:12px Arial, sans-serif; fill:#475569}
                </style>
                <rect x="80" y="36" width="660" height="56" rx="8" fill="#eef2ff" stroke="#dbeafe"/>
                <text x="410" y="72" text-anchor="middle" class="h">new Estudiante("Carlos", "2024002")</text>

                <rect x="160" y="112" width="320" height="48" rx="8" fill="#fff" stroke="#e2e8f0"/>
                <text x="320" y="140" text-anchor="middle" class="s">Estudiante(string, string)
: this(n, c, 18)</text>

                <rect x="480" y="112" width="320" height="48" rx="8" fill="#fff" stroke="#e2e8f0"/>
                <text x="640" y="140" text-anchor="middle" class="s">Estudiante(string, string, int)
- Validaciones · - Asignaciones</text>

                <path d="M320 112 L480 112" stroke="#0b2d6b" stroke-width="2" marker-end="url(#arrow)"/>
                <defs><marker id="arrow" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto"><path d="M0,0 L6,4 L0,8 z" fill="#0b2d6b"/></marker></defs>
              </svg>
              <figcaption>Flujo de encadenamiento: el constructor con menos parámetros delega al principal usando <code>: this(...)</code>, centralizando validaciones y asignaciones.</figcaption>
            </figure>
            </div>
        </section>

        <section id="static">
            <h2>Static vs Instance</h2>

            <h3>STATIC (Compartido)</h3>
            <p>Los miembros <code>static</code> son <strong>compartidos por TODAS</strong> las instancias de una clase. No requieren un objeto para ser accedidos.</p>
            <ul>
                <li>Una sola copia en memoria (compartida)</li>
                <li>Acceso desde la clase (no desde el objeto)</li>
                <li>Usan la palabra clave <code>static</code></li>
                <li>Viven durante toda la vida del programa</li>
            </ul>

            <h3>Instance (Normal)</h3>
            <p>Los miembros de instancia son <strong>unicos para cada objeto</strong>.</p>
            <ul>
                <li>Una copia por cada objeto</li>
                <li>Acceso desde el objeto</li>
                <li>Viven mientras el objeto exista</li>
            </ul>

            <h3>Ejemplo Visual</h3>
            <pre><code class="language-csharp">public class Contador
{
    // STATIC: Compartido por todos
    public static int Global = 0;

    // INSTANCE: Unico por objeto
    public int Instancia = 0;

    public Contador()
    {
        Global++;     // Incrementa el contador compartido
        Instancia++; // Incrementa el contador de este objeto
    }
}

// Uso
var c1 = new Contador(); // Global=1, Instancia=1
var c2 = new Contador(); // Global=2, Instancia=1
var c3 = new Contador(); // Global=3, Instancia=1

// Static: desde la clase
Console.WriteLine(Contador.Global); // 3

// Instance: desde el objeto
Console.WriteLine(c1.Instancia);   // 1
Console.WriteLine(c2.Instancia);   // 1
Console.WriteLine(c3.Instancia);   // 1</code></pre>

            <h3>Cuando Usar Static</h3>
            <table>
                <thead>
                    <tr>
                        <th>Usa static para</th>
                        <th>NO uses static para</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>Constantes (<code>Math.PI</code>)</td><td>Datos que varian por objeto</td></tr>
                    <tr><td>Utilidades (<code>Console.WriteLine</code>)</td><td>Estado del objeto</td></tr>
                    <tr><td>Configuraciones globales</td><td>Metodos que usan estado de instancia</td></tr>
                    <tr><td>Contadores compartidos</td><td>Propiedades del objeto</td></tr>
                </tbody>
            </table>
        </section>

        <section id="class-vs-struct">
            <h2>class vs struct</h2>

            <h3>Diferencias Fundamentales</h3>
            <table>
                <thead>
                    <tr>
                        <th>Aspecto</th>
                        <th>class</th>
                        <th>struct</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><strong>Tipo</strong></td><td>Reference type</td><td>Value type</td></tr>
                    <tr><td><strong>Ubicación</strong></td><td>Heap</td><td>Stack</td></tr>
                    <tr><td><strong>Asignacion</strong></td><td>Copia referencia</td><td>Copia valor completo</td></tr>
                    <tr><td><strong>Herencia</strong></td><td>Soporta herencia</td><td>No soporta herencia (solo interfaces)</td></tr>
                    <tr><td><strong>NULL</strong></td><td>Puede ser <code>null</code></td><td>No puede ser <code>null</code></td></tr>
                    <tr><td><strong>Constructor</strong></td><td>Sin constructor default</td><td>Siempre tiene constructor default</td></tr>
                    <tr><td><strong>Uso típico</strong></td><td>Objetos grandes, complejos</td><td>Datos pequeños, inmutables</td></tr>
                </tbody>
            </table>

            <h3>Ejemplo Comparativo</h3>
            <pre><code class="language-csharp">// CLASS (Reference Type)
public class PersonaClass
{
    public string Nombre { get; set; }
    public int Edad { get; set; }
}

// STRUCT (Value Type)
public struct PersonaStruct
{
    public string Nombre { get; set; }
    public int Edad { get; set; }
}

// Uso
var pc1 = new PersonaClass { Nombre = "Juan", Edad = 25 };
var pc2 = pc1;              // Copia REFERENCIA
pc2.Nombre = "Maria";
Console.WriteLine(pc1.Nombre); // "Maria" (!!) - ambos referencian el mismo objeto

var ps1 = new PersonaStruct { Nombre = "Juan", Edad = 25 };
var ps2 = ps1;              // Copia VALOR completo
ps2.Nombre = "Maria";
Console.WriteLine(ps1.Nombre); // "Juan" - independientes</code></pre>

            <div class="highlight-box">
                <h4>Cuando Usar struct</h4>
                <p>Usa <code>struct</code> cuando:</p>
                <ul>
                    <li>El tipo es <strong>pequeño</strong> (menos de 16 bytes)</li>
                    <li>Es <strong>inmutable</strong> (no cambia después de crear)</li>
                    <li>Representa <strong>un solo valor</strong> (como un primitivo)</li>
                    <li>No necesitas <strong>herencia</strong></li>
                </ul>
                <p><strong>Ejemplos:</strong> <code>Point</code>, <code>Size</code>, <code>Color</code>, <code>DateTime</code> (partial)</p>
            </div>
        </section>
        </section>

        <section id="ejemplos">
            <h2>Ejemplos</h2>
            <p>Los ejemplos de código están integrados en las secciones teóricas anteriores. Consulte cada sección para ver ejemplos prácticos de:</p>
            <ul>
                <li>Definición de clases y objetos</li>
                <li>Implementación de encapsulamiento</li>
                <li>Uso de propiedades y constructores</li>
                <li>Miembros estáticos vs de instancia</li>
                <li>Diferencias entre class y struct</li>
            </ul>
        </section>

        <section id="practica">
            <h2>Práctica / Laboratorio</h2>

            <section class="actividad">
                <h3>Actividad: Ejercicio Guiado - Sistema de Biblioteca (30 min)</h3>
                <p><strong>Tipo:</strong> Opcional / práctica</p>
                <p><strong>Relacionado con:</strong> Ninguno</p>
                <p><strong>Entregable:</strong> Clase Libro con encapsulamiento</p>
                <p><strong>Tiempo estimado:</strong> 30 minutos</p>
                <p><strong>Criterios de éxito:</strong> Comprensión de encapsulamiento, propiedades y constructores</p>
                <p><strong>Objetivo:</strong> Implementar una clase <code>Libro</code> con encapsulamiento adecuado, propiedades y constructores.</p>

            <h4>Requisitos</h4>
            <ul>
                <li>Campos privados para titulo, autor, anio y número de páginas</li>
                <li>Propiedades publicas con validacion</li>
                <li>Constructor parametrizado</li>
                <li>Método <code>EstaAntiguo()</code> que retorne true si el libro es de hace más de 20 años</li>
                <li>Constructor con encadenamiento (usando <code>this</code>)</li>
            </ul>

            <h4>Checklist de Implementacion</h4>
            <table>
                <thead>
                    <tr>
                        <th>Paso</th>
                        <th>Actividad</th>
                        <th>Tiempo</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>1</td><td>Crear proyecto de consola en Visual Studio</td><td>3 min</td></tr>
                    <tr><td>2</td><td>Definir clase <code>Libro</code> con campos privados</td><td>5 min</td></tr>
                    <tr><td>3</td><td>Implementar propiedades con validacion</td><td>8 min</td></tr>
                    <tr><td>4</td><td>Crear constructor parametrizado</td><td>5 min</td></tr>
                    <tr><td>5</td><td>Implementar constructor con encadenamiento</td><td>4 min</td></tr>
                    <tr><td>6</td><td>Implementar metodo <code>EstaAntiguo()</code></td><td>3 min</td></tr>
                    <tr><td>7</td><td>Probar en Main con varios libros</td><td>2 min</td></tr>
                </tbody>
            </table>

            <h4>Solucion de Referencia</h4>
            <pre><code class="language-csharp">public class Libro
{
    // Campos privados (convencion _camelCase)
    private string _titulo;
    private string _autor;
    private int _anio;
    private int _numeroPaginas;

    // Propiedades con validacion
    public string Titulo
    {
        get => _titulo;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("El titulo no puede estar vacio");
            _titulo = value;
        }
    }

    public string Autor
    {
        get => _autor;
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("El autor no puede estar vacio");
            _autor = value;
        }
    }

    public int Anio
    {
        get => _anio;
        set
        {
            if (value < 1000 || value > DateTime.Now.Year + 1)
                throw new ArgumentOutOfRangeException("Anio", "Año inválido");
            _anio = value;
        }
    }

    public int NumeroPaginas
    {
        get => _numeroPaginas;
        set
        {
            if (value <= 0)
                throw new ArgumentException("El número de páginas debe ser positivo");
            _numeroPaginas = value;
        }
    }

    // Constructor completo
    public Libro(string titulo, string autor, int anio, int numeroPaginas)
    {
        Titulo = titulo;
        Autor = autor;
        Anio = anio;
        NumeroPaginas = numeroPaginas;
    }

    // Constructor con encadenamiento (this)
    public Libro(string titulo, string autor, int anio)
        : this(titulo, autor, anio, 0)  // 0 paginas por defecto
    {
    }

    // Metodo de instancia
    public bool EstaAntiguo()
    {
        int anioActual = DateTime.Now.Year;
        return (anioActual - _anio) > 20;
    }

    // Propiedad calculada
    public string InfoCorta => $"{_titulo} ({_autor})";
}

// Uso en Main
class Program
{
    static void Main()
    {
        var libro1 = new Libro("Cien Años de Soledad", "Gabriel García Márquez", 1967, 417);
        var libro2 = new Libro("Don Quijote", "Miguel de Cervantes", 1605);

        Console.WriteLine(libro1.InfoCorta);
        Console.WriteLine($"Es antiguo? {libro1.EstaAntiguo()}");  // True

        Console.WriteLine(libro2.InfoCorta);
        Console.WriteLine($"Es antiguo? {libro2.EstaAntiguo()}");  // True
    }
}</code></pre>

            <h3>Errores Comunes y Como Evitarlos</h3>
            <table>
                <thead>
                    <tr>
                        <th>Error</th>
                        <th>Causa</th>
                        <th>Solucion</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>ArgumentException</td><td>Titulo o autor vacio</td><td>Validar con <code>IsNullOrWhiteSpace</code></td></tr>
                    <tr><td>ArgumentOutOfRangeException</td><td>Anio fuera de rango</td><td>Validar rango 1000 - anio actual + 1</td></tr>
                    <tr><td>Logica incorrecta</td><td>No usar <code>DateTime.Now.Year</code></td><td>Obtener anio actual dinamicamente</td></tr>
                    <tr><td>Encadenamiento roto</td><td>Olvidar usar <code>this</code></td><td>Siempre llamar a <code>: this(...)</code></td></tr>
                </tbody>
            </table>

            <div class="success-box">
                <h4>Consejo Pro</h4>
                <p>Usa <strong>propiedades autoimplementadas</strong> cuando no necesites validacion. Solo usa backing fields (<code>_campo</code>) cuando requieras logica en get/set.</p>
            </div>
        </section>

        <section id="ejercicios">
            <h2>Ejercicios</h2>

            <section class="actividad">
                <h3>Actividad: Ejercicio 1 - Cuenta de Ahorros (20 min)</h3>
                <p><strong>Tipo:</strong> Opcional / práctica</p>
                <p><strong>Relacionado con:</strong> Ninguno</p>
                <p><strong>Entregable:</strong> Clase CuentaAhorros con validaciones</p>
                <p><strong>Tiempo estimado:</strong> 20 minutos</p>
                <p><strong>Criterios de éxito:</strong> Aplicación de encapsulamiento y métodos</p>
            <p><strong>Nivel:</strong> Basico | <strong>Duracion:</strong> 20 minutos</p>
            <p>Implementar una clase <code>CuentaAhorros</code> con:</p>
            <ul>
                <li>Saldo inicial obligatorio (minimo $100,000)</li>
                <li>Tasa de interes anual (por defecto 5%)</li>
                <li>Metodos <code>Depositar</code> y <code>Retirar</code> con validacion</li>
                <li>Metodo <code>CalcularInteresMensual()</code> que retorne el interes del mes</li>
                <li>Propiedad <code>Saldo</code> solo lectura</li>
            </ul>
            <div class="highlight-box">
                <h4>Checklist</h4>
                <ul>
                    <li>[ ] Constructor valida saldo minimo</li>
                    <li>[ ] Depositar rechaza montos negativos o cero</li>
                    <li>[ ] Retirar rechaza si saldo insuficiente</li>
                    <li>[ ] Calculo de interes es correcto (tasa / 12)</li>
                    <li>[ ] Propiedad Saldo no tiene set</li>
                </ul>
            </div>

            </section>

            <section class="actividad">
                <h3>Actividad: Ejercicio 2 - Sistema de Estudiantes (30 min)</h3>
                <p><strong>Tipo:</strong> Opcional / práctica</p>
                <p><strong>Relacionado con:</strong> Ninguno</p>
                <p><strong>Entregable:</strong> Clase Estudiante con lista de notas</p>
                <p><strong>Tiempo estimado:</strong> 30 minutos</p>
                <p><strong>Criterios de éxito:</strong> Uso de colecciones, propiedades calculadas</p>
            <p><strong>Nivel:</strong> Intermedio | <strong>Duracion:</strong> 30 minutos</p>
            <p>Implementar una clase <code>Estudiante</code> con:</p>
            <ul>
                <li>Propiedades: Nombre, Codigo, Carrera (con valores por defecto)</li>
                <li>Lista privada de notas (0.0 a 5.0)</li>
                <li>Metodo <code>AgregarNota(double nota)</code> con validacion de rango</li>
                <li>Propiedad calculada <code>Promedio</code></li>
                <li>Propiedad calculada <code>Estado</code> que retorne "APROBADO" o "REPROBADO"</li>
                <li>Constructor que reciba nombre y codigo (carrera por defecto "Sin definir")</li>
                <li>Contador static <code>TotalEstudiantes</code> que se incremente en cada constructor</li>
            </ul>
            <div class="highlight-box">
                <h4>Checklist</h4>
                <ul>
                    <li>[ ] Notas se validan entre 0.0 y 5.0</li>
                    <li>[ ] Promedio se calcula correctamente (suma / cantidad)</li>
                    <li>[ ] Estado usa Promedio >= 3.0 como umbral</li>
                    <li>[ ] Constructor usa <code>: this()</code> para encadenamiento</li>
                    <li>[ ] Contador static se incrementa automaticamente</li>
                </ul>
            </div>

            </section>

            <section class="actividad">
                <h3>Actividad: Ejercicio 3 - Producto con Inventario (40 min)</h3>
                <p><strong>Tipo:</strong> Opcional / práctica</p>
                <p><strong>Relacionado con:</strong> Ninguno</p>
                <p><strong>Entregable:</strong> Clase Producto para sistema de inventario</p>
                <p><strong>Tiempo estimado:</strong> 40 minutos</p>
                <p><strong>Criterios de éxito:</strong> Validaciones, propiedades inmutables, constructores encadenados</p>
            <p><strong>Nivel:</strong> Avanzado | <strong>Duracion:</strong> 40 minutos</p>
            <p>Implementar una clase <code>Producto</code> para un sistema de inventario:</p>
            <ul>
                <li>Codigo (string, inmutable despues de crear)</li>
                <li>Nombre, Descripcion, Precio, Stock</li>
                <li>Propiedad <code>Precio</code> no permite valores negativos</li>
                <li>Metodo <code>ActualizarStock(int cantidad)</code> que suma o resta</li>
                <li>Metodo <code>HayStock()</code> retorne true si stock > 0</li>
                <li>Propiedad calculada <code>ValorInventario</code> = Precio * Stock</li>
                <li>Constructor con encadenamiento multiple</li>
                <li>Validar que el codigo no sea vacio y tenga formato especifico (ej: "PROD-XXX")</li>
            </ul>
            <div class="highlight-box">
                <h4>Checklist</h4>
                <ul>
                    <li>[ ] Codigo usa <code>{ get; init; }</code> para inmutabilidad</li>
                    <li>[ ] Codigo valida formato con Regex o string operations</li>
                    <li>[ ] Precio lanza excepcion si es negativo</li>
                    <li>[ ] ActualizarStock acepta valores positivos y negativos</li>
                    <li>[ ] ValorInventario es calculado (sin backing field)</li>
                    <li>[ ] Dos constructores encadenados con <code>this</code></li>
                </ul>
            </div>

            </section>

            <section class="actividad">
                <h3>Actividad: Tarea para Casa - Clase Película (60 min)</h3>
                <p><strong>Tipo:</strong> Opcional / práctica</p>
                <p><strong>Relacionado con:</strong> Ninguno</p>
                <p><strong>Entregable:</strong> Clase Pelicula con todas las funcionalidades</p>
                <p><strong>Tiempo estimado:</strong> 60 minutos</p>
                <p><strong>Criterios de éxito:</strong> Integración de todos los conceptos de la clase</p>
                <div class="warning-box">
                <h4>Entregable: Clase <code>Pelicula</code></h4>
                <p><strong>Fecha limite:</strong> Proxima clase | <strong>Duracion estimada:</strong> 60 minutos</p>
                <p>Crear una clase <code>Pelicula</code> que modele una pelicula con:</p>
                <ul>
                    <li>Titulo, Director, Anio, Genero, Duracion (minutos)</li>
                    <li>Lista de actores (array o List&lt;string&gt;)</li>
                    <li>Constructor completo + constructor con encadenamiento</li>
                    <li>Metodo <code>EsClasica()</code> (anio < 1990)</li>
                    <li>Metodo <code>AgregarActor(string actor)</code></li>
                    <li>Propiedad calculada <code>InfoBreve</code> = "Titulo (Director, Anio)"</li>
                    <li>Validaciones apropiadas en todas las propiedades</li>
                    <li>Contador static de peliculas creadas</li>
                </ul>
                <p><strong>Requisitos de entrega:</strong></p>
                <ul>
                    <li>Repositorio en GitHub con README.md</li>
                    <li>Codigo fuente en C# con comentarios</li>
                    <li>Programa Main que demuestre todas las funcionalidades</li>
                    <li>Capturas de pantalla de la ejecucion</li>
                </ul>
            </div>
            </section>
        </section>

        <section id="resumen">
            <h2>Resumen de la Clase</h2>

            <h3>Conceptos Clave Aprendidos</h3>
            <table>
                <thead>
                    <tr>
                        <th>Tema</th>
                        <th>Descripción</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td><strong>POO</strong></td><td>Paradigma basado en objetos que unen datos y comportamiento</td></tr>
                    <tr><td><strong>Clase</strong></td><td>Plantilla o definición abstracta para crear objetos</td></tr>
                    <tr><td><strong>Objeto</strong></td><td>Instancia concreta de una clase que ocupa memoria</td></tr>
                    <tr><td><strong>Encapsulamiento</strong></td><td>Ocultar detalles internos, exponer interfaz controlada</td></tr>
                    <tr><td><strong>Propiedades</strong></td><td>Syntactic sugar para getters/setters con validación</td></tr>
                    <tr><td><strong>Constructores</strong></td><td>Métodos especiales para inicializar objetos</td></tr>
                    <tr><td><strong>static</strong></td><td>Miembros compartidos por todas las instancias</td></tr>
                    <tr><td><strong>class vs struct</strong></td><td>Reference type (heap) vs Value type (stack)</td></tr>
                </tbody>
            </table>

            <h3>Habilidades Adquiridas</h3>
            <ul>
                <li>Definir clases con propiedades y métodos</li>
                <li>Crear objetos usando <code>new</code></li>
                <li>Aplicar encapsulamiento con modificadores de acceso</li>
                <li>Usar propiedades para acceso controlado a datos</li>
                <li>Implementar constructores con encadenamiento</li>
                <li>Diferenciar entre static y instance members</li>
            </ul>

            <h3>Próximos Pasos</h3>
            <ul>
                <li><strong>Clase 3:</strong> Herencia y Polimorfismo</li>
                <li>Practicar creando clases del dominio</li>
                <li>Aplicar encapsulamiento en todos los proyectos</li>
            </ul>
        </section>

        <section id="referencias">
            <h2>Referencias</h2>
            <h3>Documentación oficial</h3>
            <ul>
                <li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/" target="_blank" rel="noopener">Programación orientada a objetos en C#</a> - Guía oficial de Microsoft</li>
                <li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/" target="_blank" rel="noopener">Clases y structs</a> - Referencia completa</li>
                <li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties/" target="_blank" rel="noopener">Propiedades en C#</a> - Uso de propiedades</li>
                <li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers/" target="_blank" rel="noopener">Modificadores de acceso</a> - public, private, protected</li>
            </ul>
            <h3>Fuentes consultadas para esta clase</h3>
            <p><small>Contenido basado en el syllabus oficial IF0100 y documentación de Microsoft Learn. No se requirió búsqueda web adicional para esta clase.</small></p>
        </section>
    </div>

    <a href="#inicio" class="back-to-top">&uarr;</a>

    <footer>
        <p><strong>IF0100 - Lenguaje de Programación OO II</strong></p>
        <p>UNAULA - Ingeniería Informática - 2026-I</p>
        <p style="margin-top: 15px; font-size: 0.9em; opacity: 0.8;">
            Contacto: [correo del docente] | Repositorio: [enlace del curso]
        </p>
    </footer>
</body>
</html>
