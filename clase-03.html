<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clase 03 â€” Herencia y Polimorfismo (POO II)</title>
  <style>
    :root {
      --bg: #f7f7f4;
      --ink: #1f2933;
      --muted: #52606d;
      --brand: #1e3a8a;
      --accent: #3b82f6;
      --card: #ffffff;
      --line: #d9e2ec;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 0;
      color: var(--ink);
      background: var(--bg);
    }
    header {
      background: linear-gradient(135deg, #0b5a3c, #10b981);
      padding: 36px 20px 28px;
      color: #fff;
    }
    header .wrap {
      max-width: 1100px;
      margin: 0 auto;
    }
    header h1 {
      margin: 8px 0 10px 0;
      font-size: 2.2rem;
    }
    header .meta {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
      margin-top: 18px;
      background: rgba(255, 255, 255, 0.15);
      padding: 16px;
      border-radius: 12px;
    }
    header ul {
      margin: 8px 0 0 18px;
    }
    nav {
      max-width: 1100px;
      margin: 18px auto 0;
      padding: 14px 18px;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
    }
    nav ul {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 8px 14px;
    }
    nav a {
      color: var(--brand);
      text-decoration: none;
      padding: 8px 10px;
      border-radius: 8px;
      background: #eef2ff;
      display: block;
    }
    nav a:hover { background: #dbeafe; }
    main {
      max-width: 1100px;
      margin: 18px auto 60px;
      padding: 0 20px;
    }
    section {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 28px;
      margin: 20px 0;
    }
    h2 {
      color: #0b5a3c;
      font-size: 1.8rem;
      margin-top: 0;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 3px solid #10b981;
    }
    h3 {
      color: #047857;
      font-size: 1.4rem;
      margin-top: 28px;
      margin-bottom: 15px;
    }
    h4 {
      color: #059669;
      font-size: 1.15rem;
      margin-top: 22px;
      margin-bottom: 12px;
    }
    pre {
      background: #0b1020;
      color: #e2e8f0;
      padding: 16px;
      border-radius: 10px;
      overflow-x: auto;
      margin: 15px 0;
    }
    code {
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.9em;
    }
    p code, li code {
      background: #d1fae5;
      color: #065f46;
      padding: 2px 6px;
      border-radius: 4px;
    }
    figure {
      margin: 24px 0;
      padding: 16px;
      border: 1px dashed var(--line);
      border-radius: 10px;
      background: #fbfbff;
      text-align: center;
    }
    figure img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
    }
    figcaption {
      margin-top: 12px;
      font-size: 0.95rem;
      color: var(--muted);
      font-style: italic;
    }
    .diagram {
      font-family: 'Consolas', 'Monaco', monospace;
      background: #f0fdf4;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      overflow-x: auto;
      border: 2px solid #10b981;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border: 1px solid var(--line);
    }
    th {
      background: #0b5a3c;
      color: white;
      font-weight: 600;
    }
    tr:nth-child(even) {
      background: #f0fdf4;
    }
    ul, ol {
      margin-left: 25px;
      margin-bottom: 15px;
    }
    li {
      margin-bottom: 8px;
    }
    .checklist {
      background: #fef3c7;
      padding: 16px;
      border-left: 4px solid var(--warning);
      border-radius: 8px;
      margin: 20px 0;
    }
    .checklist ul {
      list-style: none;
      margin-left: 0;
    }
    .checklist li:before {
      content: "â˜ ";
      font-weight: bold;
      color: var(--warning);
    }
    .highlight-box {
      background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
      padding: 20px;
      border-radius: 10px;
      border-left: 4px solid #10b981;
      margin: 20px 0;
    }
    .warning-box {
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      padding: 20px;
      border-radius: 10px;
      border-left: 4px solid var(--warning);
      margin: 20px 0;
    }
    .info-box {
      background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
      padding: 20px;
      border-radius: 10px;
      border-left: 4px solid var(--accent);
      margin: 20px 0;
    }
    .comparison-table {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }
    .comparison-table > div {
      background: #f0fdf4;
      padding: 20px;
      border-radius: 10px;
      border: 1px solid #10b981;
    }
    .comparison-table h4 {
      color: #065f46;
      margin-top: 0;
    }
    @media (max-width: 768px) {
      .comparison-table {
        grid-template-columns: 1fr;
      }
      header h1 {
        font-size: 1.6rem;
      }
    }
    footer {
      background: #1e293b;
      color: white;
      text-align: center;
      padding: 30px;
      margin-top: 50px;
    }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div>IF0100 - Lenguaje de ProgramaciÃ³n OO II | Unidad 2</div>
      <h1>Clase 03: Herencia y Polimorfismo</h1>
      <div>DuraciÃ³n: 90 minutos | Semana 3</div>
      <div class="meta">
        <div>
          <strong>Objetivos de Aprendizaje</strong>
          <ul>
            <li>Comprender el concepto de herencia y la relaciÃ³n "es-un"</li>
            <li>Aplicar tipos de herencia (simple, jerÃ¡rquica) en C#</li>
            <li>Implementar polimorfismo mediante override y virtual</li>
            <li>Utilizar <code>base</code> para invocar constructores padre</li>
            <li>Aplicar el principio de sustituciÃ³n de Liskov</li>
          </ul>
        </div>
        <div>
          <strong>Prerrequisitos</strong>
          <ul>
            <li>Clase 02: Clases, objetos y encapsulamiento</li>
            <li>Visual Studio 2022 con .NET 8 instalado</li>
            <li>Conocimiento de modificadores de acceso</li>
            <li>Windows 10/11 con permisos de desarrollo</li>
          </ul>
        </div>
      </div>
    </div>
  </header>

  <nav>
    <ul>
      <li><a href="#teoria">1. TeorÃ­a: Herencia</a></li>
      <li><a href="#tipos-herencia">2. Tipos de Herencia</a></li>
      <li><a href="#liskov">3. Principio de Liskov</a></li>
      <li><a href="#ejemplos">4. Ejemplos PrÃ¡cticos</a></li>
      <li><a href="#practica">5. Laboratorio Guiado</a></li>
      <li><a href="#ejercicios">6. Ejercicios</a></li>
      <li><a href="#referencias">7. Referencias</a></li>
    </ul>
  </nav>

  <main>
    <section id="teoria">
      <h2>1. TeorÃ­a: Â¿QuÃ© es la Herencia?</h2>
      
      <h3>DefiniciÃ³n y Concepto Fundamental</h3>
      <p>La <strong>herencia</strong> es uno de los pilares fundamentales de la ProgramaciÃ³n Orientada a Objetos. Permite definir una nueva clase (subclase o clase derivada) que reutiliza, extiende y modifica el comportamiento de una clase existente (superclase o clase base).</p>
      
      <div class="highlight-box">
        <h4>La RelaciÃ³n "Es-Un" (Is-A)</h4>
        <p>La herencia modela una relaciÃ³n jerÃ¡rquica donde la subclase <strong>"es un tipo de"</strong> la superclase. Esta relaciÃ³n debe ser natural y lÃ³gica:</p>
        <ul>
          <li>âœ… Un <code>Gerente</code> <strong>es un</strong> <code>Empleado</code></li>
          <li>âœ… Un <code>Perro</code> <strong>es un</strong> <code>Animal</code></li>
          <li>âœ… Un <code>CÃ­rculo</code> <strong>es una</strong> <code>Figura</code></li>
          <li>âŒ Un <code>Auto</code> <strong>NO es un</strong> <code>Motor</code> (aquÃ­ va composiciÃ³n, no herencia)</li>
        </ul>
      </div>

      <h3>Â¿Por quÃ© usar Herencia?</h3>
      <table>
        <thead>
          <tr>
            <th>Beneficio</th>
            <th>DescripciÃ³n</th>
            <th>Ejemplo PrÃ¡ctico</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>ReutilizaciÃ³n de cÃ³digo</strong></td>
            <td>Evita duplicar cÃ³digo comÃºn en mÃºltiples clases</td>
            <td>Todos los empleados tienen nombre e ID; se define una sola vez en la clase base</td>
          </tr>
          <tr>
            <td><strong>Extensibilidad</strong></td>
            <td>Agregar nuevas funcionalidades sin modificar cÃ³digo existente</td>
            <td>Crear nuevo tipo de empleado sin cambiar las clases existentes</td>
          </tr>
          <tr>
            <td><strong>Polimorfismo</strong></td>
            <td>Tratar objetos de diferentes clases de forma uniforme</td>
            <td>Procesar una lista mixta de Gerentes y Desarrolladores como Empleados</td>
          </tr>
          <tr>
            <td><strong>JerarquÃ­a lÃ³gica</strong></td>
            <td>Organiza conceptos segÃºn su relaciÃ³n natural</td>
            <td>VehÃ­culo â†’ Auto â†’ AutoElÃ©ctrico</td>
          </tr>
        </tbody>
      </table>

      <h3>Conceptos Clave</h3>
      <div class="comparison-table">
        <div>
          <h4>ğŸ”· Superclase / Clase Base</h4>
          <p>La clase que proporciona los miembros (campos, mÃ©todos, propiedades) que serÃ¡n heredados.</p>
          <ul>
            <li>Define el comportamiento comÃºn</li>
            <li>Puede ser <code>abstract</code> (no se instancia)</li>
            <li>Usa <code>virtual</code> para mÃ©todos sobreescribibles</li>
          </ul>
          <pre><code>public class Empleado
{
    public string Nombre { get; set; }
    public virtual void Trabajar() { }
}</code></pre>
        </div>
        <div>
          <h4>ğŸ”¶ Subclase / Clase Derivada</h4>
          <p>La clase que hereda de la superclase y puede aÃ±adir o modificar comportamiento.</p>
          <ul>
            <li>Usa <code>:</code> para heredar</li>
            <li>Usa <code>override</code> para modificar comportamiento</li>
            <li>Accede a miembros heredados</li>
          </ul>
          <pre><code>public class Gerente : Empleado
{
    public override void Trabajar() 
    { 
        // Comportamiento especÃ­fico
    }
}</code></pre>
        </div>
      </div>

      <h3>Sobrescritura (Override) vs Sobrecarga (Overload)</h3>
      <table>
        <thead>
          <tr>
            <th>CaracterÃ­stica</th>
            <th>Sobrescritura (Override)</th>
            <th>Sobrecarga (Overload)</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>DefiniciÃ³n</strong></td>
            <td>Reemplazar un mÃ©todo de la clase padre en la clase hija</td>
            <td>MÃºltiples mÃ©todos con mismo nombre pero diferentes parÃ¡metros</td>
          </tr>
          <tr>
            <td><strong>Requisito</strong></td>
            <td>Requiere herencia y mÃ©todo marcado como <code>virtual</code></td>
            <td>Mismo alcance, diferente firma (parÃ¡metros)</td>
          </tr>
          <tr>
            <td><strong>Enlace</strong></td>
            <td>Enlace dinÃ¡mico (runtime polymorphism)</td>
            <td>Enlace estÃ¡tico (compile-time polymorphism)</td>
          </tr>
          <tr>
            <td><strong>Sintaxis</strong></td>
            <td><code>override</code> + mismo nombre y firma</td>
            <td>Mismo nombre, diferentes parÃ¡metros</td>
          </tr>
        </tbody>
      </table>

      <figure>
        <div class="diagram">
<pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    POLIMORFISMO EN C#                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   COMPILE-TIME              â”‚   RUNTIME                         â”‚
â”‚   (Sobrecarga)              â”‚   (Sobrescritura)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                             â”‚                                   â”‚
â”‚  void Procesar(int x)       â”‚   class Animal                    â”‚
â”‚  void Procesar(string s)    â”‚   {                               â”‚
â”‚  void Procesar(int x,       â”‚       public virtual void         â”‚
â”‚              string s)      â”‚                     Hablar() { }  â”‚
â”‚                             â”‚   }                               â”‚
â”‚  El compilador decide       â”‚                                   â”‚
â”‚  cuÃ¡l mÃ©todo llamar         â”‚   class Perro : Animal            â”‚
â”‚  segÃºn los parÃ¡metros       â”‚   {                               â”‚
â”‚                             â”‚       public override void        â”‚
â”‚                             â”‚                     Hablar() { }  â”‚
â”‚                             â”‚   }                               â”‚
â”‚                             â”‚                                   â”‚
â”‚                             â”‚   Animal a = new Perro();         â”‚
â”‚                             â”‚   a.Hablar(); // "Guau!"          â”‚
â”‚                             â”‚                                   â”‚
â”‚                             â”‚   La JVM/CLR decide en runtime    â”‚
â”‚                             â”‚   quÃ© mÃ©todo ejecutar             â”‚
â”‚                             â”‚                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
        </div>
        <figcaption>ComparaciÃ³n entre polimorfismo en tiempo de compilaciÃ³n (sobrecarga) y en tiempo de ejecuciÃ³n (sobrescritura)</figcaption>
      </figure>
    </section>

    <section id="tipos-herencia">
      <h2>2. Tipos de Herencia</h2>

      <h3>Herencia Simple</h3>
      <p>C# solo permite <strong>herencia simple de clases</strong>: una clase puede heredar directamente de <strong>una Ãºnica</strong> clase base. Esto evita la ambigÃ¼edad del "diamante" que ocurre en herencia mÃºltiple.</p>

      <div class="diagram">
<pre>
                    HERENCIA SIMPLE EN C#
                    
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚   Persona   â”‚  â† Clase Base
                         â”‚  - Nombre   â”‚
                         â”‚  - Edad     â”‚
                         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                â”‚ extends
                                â–¼
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚  Empleado   â”‚  â† Clase Derivada
                         â”‚  - Salario  â”‚
                         â”‚  - Cargo    â”‚
                         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                â”‚ extends
                                â–¼
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚   Gerente   â”‚  â† Clase Derivada
                         â”‚  - Bonos    â”‚
                         â”‚  - Equipo   â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
      </div>

      <h3>Herencia JerÃ¡rquica</h3>
      <p>Una clase base puede tener <strong>mÃºltiples clases derivadas</strong>, creando una jerarquÃ­a en forma de Ã¡rbol.</p>

      <div class="diagram">
<pre>
                    HERENCIA JERÃRQUICA
                    
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚   Figura    â”‚
                              â”‚   abstract  â”‚
                              â”‚  + Area()   â”‚
                              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                                     â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚                         â”‚                         â”‚
           â–¼                         â–¼                         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Rectangulo â”‚           â”‚   Circulo   â”‚           â”‚  Triangulo  â”‚
    â”‚  - Ancho    â”‚           â”‚  - Radio    â”‚           â”‚  - Base     â”‚
    â”‚  - Alto     â”‚           â”‚             â”‚           â”‚  - Altura   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

    Todas implementan: override double Area()
</pre>
      </div>

      <h3>Herencia Multinivel</h3>
      <p>Una clase derivada puede a su vez servir como clase base para otra clase, creando cadenas de herencia.</p>

      <div class="diagram">
<pre>
                    HERENCIA MULTINIVEL
                    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Vehiculo  â”‚  â† Clase base
    â”‚  - Marca    â”‚     (nivel 0)
    â”‚  - Modelo   â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
           â”‚ extends
           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Auto       â”‚  â† Clase derivada
    â”‚  - Puertas  â”‚     (nivel 1)
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
           â”‚ extends
           â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚AutoElectricoâ”‚  â† Clase derivada
    â”‚  - Bateria  â”‚     (nivel 2)
    â”‚  - Autonomiaâ”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
      </div>

      <div class="warning-box">
        <h4>âš ï¸ Herencia MÃºltiple de Interfaces</h4>
        <p>Aunque C# no permite herencia mÃºltiple de <strong>clases</strong>, sÃ­ permite implementar <strong>mÃºltiples interfaces</strong>:</p>
        <pre><code>public class Pato : Animal, IVolador, INadador, ICaminador
{
    // Implementa todos los mÃ©todos de las interfaces
}</code></pre>
        <p>Esto permite lograr polimorfismo mÃºltiple sin los problemas de la herencia mÃºltiple de clases.</p>
      </div>
    </section>

    <section id="liskov">
      <h2>3. Principio de SustituciÃ³n de Liskov (LSP)</h2>

      <h3>DefiniciÃ³n Formal</h3>
      <p>El <strong>Principio de SustituciÃ³n de Liskov (LSP)</strong>, formulado por Barbara Liskov en 1987, establece que:</p>
      
      <div class="highlight-box">
        <p><em>"Si S es un subtipo de T, entonces los objetos de tipo T pueden ser reemplazados por objetos de tipo S sin alterar ninguna de las propiedades deseables del programa."</em></p>
      </div>

      <h3>En TÃ©rminos PrÃ¡cticos</h3>
      <p>Una clase derivada debe poder sustituir a su clase base <strong>sin que el programa falle o se comporte de manera inesperada</strong>.</p>

      <div class="comparison-table">
        <div>
          <h4>âœ… CUMPLE LSP</h4>
          <pre><code>public class Rectangulo
{
    public virtual int Ancho { get; set; }
    public virtual int Alto { get; set; }
    public int Area => Ancho * Alto;
}

public class Cuadrado : Rectangulo
{
    // Cuadrado ES un Rectangulo especial
    // donde Ancho == Alto
    public override int Ancho 
    { 
        set { base.Ancho = base.Alto = value; }
    }
    public override int Alto 
    { 
        set { base.Ancho = base.Alto = value; }
    }
}</code></pre>
        </div>
        <div>
          <h4>âŒ VIOLA LSP</h4>
          <pre><code>public class Pajaro
{
    public virtual void Volar() { }
}

public class Pinguino : Pajaro
{
    // PROBLEMA: Un pingÃ¼ino ES un pÃ¡jaro
    // pero NO puede volar
    public override void Volar()
    {
        throw new InvalidOperationException(
            "Los pingÃ¼inos no vuelan!");
    }
}</code></pre>
        </div>
      </div>

      <div class="info-box">
        <h4>Reglas para cumplir LSP</h4>
        <ol>
          <li><strong>Precondiciones:</strong> No deben ser mÃ¡s fuertes en la subclase que en la superclase</li>
          <li><strong>Postcondiciones:</strong> No deben ser mÃ¡s dÃ©biles en la subclase que en la superclase</li>
          <li><strong>Invariantes:</strong> Deben preservarse en la subclase</li>
          <li><strong>Historial:</strong> No modificar propiedades que la superclase considera inmutables</li>
        </ol>
      </div>

      <h3>Ejemplo de ViolaciÃ³n ComÃºn</h3>
      <pre><code>// Clase base
public class CuentaBancaria
{
    protected double _saldo;
    
    public virtual void Retirar(double monto)
    {
        if (monto > _saldo)
            throw new InvalidOperationException("Saldo insuficiente");
        _saldo -= monto;
    }
}

// Subclase que VIOLA LSP
public class CuentaCongelada : CuentaBancaria
{
    // PROBLEMA: Cambia el comportamiento esperado
    // Los clientes esperan poder retirar de cualquier cuenta
    public override void Retirar(double monto)
    {
        throw new InvalidOperationException(
            "Esta cuenta estÃ¡ congelada, no se permiten retiros");
    }
}

// Uso que falla:
CuentaBancaria cuenta = new CuentaCongelada();
cuenta.Depositar(1000);
cuenta.Retirar(100); // Â¡EXCEPCIÃ“N INESPERADA!</code></pre>

      <div class="warning-box">
        <h4>Â¿CÃ³mo solucionarlo?</h4>
        <p>Si una subclase no puede cumplir con el contrato de la clase base, <strong>no deberÃ­a heredar de ella</strong>. En su lugar:</p>
        <ul>
          <li>Usar <strong>composiciÃ³n</strong> en lugar de herencia</li>
          <li>Crear una jerarquÃ­a diferente: <code>CuentaBancaria</code> â†’ <code>CuentaActiva</code> y <code>CuentaCongelada</code> como hermanas</li>
          <li>Usar el patrÃ³n <strong>Estado (State)</strong> para cambiar comportamiento dinÃ¡micamente</li>
        </ul>
      </div>
    </section>

    <section id="ejemplos">
      <h2>4. Ejemplos PrÃ¡cticos</h2>

      <h3>Ejemplo 1: JerarquÃ­a de Empleados</h3>
      <p>ImplementaciÃ³n de una jerarquÃ­a completa con <code>Empleado</code> como clase base y <code>Gerente</code> y <code>Desarrollador</code> como subclases.</p>

      <pre><code>// ============================================
// CLASE BASE: Empleado
// ============================================
public class Empleado
{
    // Propiedades comunes a todos los empleados
    public string Nombre { get; set; }
    public int Id { get; set; }
    public double SalarioBase { get; set; }
    
    // Constructor de la clase base
    public Empleado(string nombre, int id, double salarioBase)
    {
        Nombre = nombre;
        Id = id;
        SalarioBase = salarioBase;
    }
    
    // MÃ©todo virtual: puede ser sobreescrito
    public virtual void Trabajar()
    {
        Console.WriteLine($"{Nombre} estÃ¡ trabajando.");
    }
    
    // MÃ©todo virtual para calcular salario
    public virtual double CalcularSalario()
    {
        return SalarioBase;
    }
    
    // MÃ©todo virtual para mostrar informaciÃ³n
    public virtual void MostrarInfo()
    {
        Console.WriteLine($"ID: {Id}, Nombre: {Nombre}");
        Console.WriteLine($"Salario Base: ${SalarioBase:F2}");
    }
}

// ============================================
// CLASE DERIVADA: Gerente
// ============================================
public class Gerente : Empleado
{
    public int CantidadSubordinados { get; set; }
    public double Bono { get; set; }
    
    // Constructor que llama al base con 'base'
    public Gerente(string nombre, int id, double salarioBase, 
                   int subordinados, double bono) 
        : base(nombre, id, salarioBase)
    {
        CantidadSubordinados = subordinados;
        Bono = bono;
    }
    
    // Sobreescribimos el comportamiento
    public override void Trabajar()
    {
        Console.WriteLine($"{Nombre} estÃ¡ supervisando a {CantidadSubordinados} empleados.");
    }
    
    public override double CalcularSalario()
    {
        return SalarioBase + Bono;
    }
    
    public override void MostrarInfo()
    {
        base.MostrarInfo(); // Reutilizamos cÃ³digo del padre
        Console.WriteLine($"Cargo: Gerente");
        Console.WriteLine($"Subordinados: {CantidadSubordinados}");
        Console.WriteLine($"Bono: ${Bono:F2}");
        Console.WriteLine($"Salario Total: ${CalcularSalario():F2}");
    }
}

// ============================================
// CLASE DERIVADA: Desarrollador
// ============================================
public class Desarrollador : Empleado
{
    public string LenguajePrincipal { get; set; }
    public int HorasExtra { get; set; }
    public double TarifaHoraExtra { get; set; }
    
    public Desarrollador(string nombre, int id, double salarioBase,
                         string lenguaje, int horasExtra, double tarifa)
        : base(nombre, id, salarioBase)
    {
        LenguajePrincipal = lenguaje;
        HorasExtra = horasExtra;
        TarifaHoraExtra = tarifa;
    }
    
    public override void Trabajar()
    {
        Console.WriteLine($"{Nombre} estÃ¡ programando en {LenguajePrincipal}.");
    }
    
    public override double CalcularSalario()
    {
        return SalarioBase + (HorasExtra * TarifaHoraExtra);
    }
    
    public override void MostrarInfo()
    {
        base.MostrarInfo();
        Console.WriteLine($"Cargo: Desarrollador");
        Console.WriteLine($"Lenguaje: {LenguajePrincipal}");
        Console.WriteLine($"Horas Extra: {HorasExtra}");
        Console.WriteLine($"Salario Total: ${CalcularSalario():F2}");
    }
}</code></pre>

      <h4>Uso PolimÃ³rfico con Arrays</h4>
      <pre><code>class Program
{
    static void Main(string[] args)
    {
        // Creamos un array de la clase base
        Empleado[] empleados = new Empleado[]
        {
            new Gerente("Ana GarcÃ­a", 101, 5000, 5, 1500),
            new Desarrollador("Carlos Ruiz", 102, 4000, "C#", 20, 25),
            new Gerente("MarÃ­a LÃ³pez", 103, 5500, 8, 2000),
            new Desarrollador("Juan PÃ©rez", 104, 3800, "Java", 15, 20)
        };
        
        Console.WriteLine("=== NÃ“MINA DE EMPLEADOS ===\n");
        
        // Polimorfismo: tratamos todos como Empleado
        foreach (Empleado emp in empleados)
        {
            emp.MostrarInfo();
            emp.Trabajar();  // Se ejecuta la versiÃ³n especÃ­fica
            Console.WriteLine("------------------------\n");
        }
        
        // Calcular total de nÃ³mina
        double totalNomina = 0;
        foreach (Empleado emp in empleados)
        {
            totalNomina += emp.CalcularSalario();
        }
        Console.WriteLine($"Total NÃ³mina: ${totalNomina:F2}");
    }
}</code></pre>

      <figure>
        <div class="diagram">
<pre>
SALIDA DEL PROGRAMA:

=== NÃ“MINA DE EMPLEADOS ===

ID: 101, Nombre: Ana GarcÃ­a
Salario Base: $5000.00
Cargo: Gerente
Subordinados: 5
Bono: $1500.00
Salario Total: $6500.00
Ana GarcÃ­a estÃ¡ supervisando a 5 empleados.
------------------------

ID: 102, Nombre: Carlos Ruiz
Salario Base: $4000.00
Cargo: Desarrollador
Lenguaje: C#
Horas Extra: 20
Salario Total: $4500.00
Carlos Ruiz estÃ¡ programando en C#.
------------------------

...
Total NÃ³mina: $20800.00
</pre>
        </div>
        <figcaption>Salida esperada del ejemplo polimÃ³rfico con jerarquÃ­a de empleados</figcaption>
      </figure>

      <h3>Ejemplo 2: Uso de la Palabra Clave <code>base</code></h3>
      <p>La palabra clave <code>base</code> se utiliza para acceder a miembros de la clase base desde la clase derivada:</p>

      <pre><code>public class Vehiculo
{
    public string Marca { get; set; }
    public string Modelo { get; set; }
    public int AÃ±o { get; set; }
    
    public Vehiculo(string marca, string modelo, int aÃ±o)
    {
        Marca = marca;
        Modelo = modelo;
        AÃ±o = aÃ±o;
    }
    
    public virtual string ObtenerDescripcion()
    {
        return $"{Marca} {Modelo} ({AÃ±o})";
    }
}

public class Auto : Vehiculo
{
    public int NumPuertas { get; set; }
    
    // 'base' llama al constructor del padre
    public Auto(string marca, string modelo, int aÃ±o, int puertas)
        : base(marca, modelo, aÃ±o)  // â† Constructor base
    {
        NumPuertas = puertas;
    }
    
    public override string ObtenerDescripcion()
    {
        // 'base' llama al mÃ©todo del padre
        string descripcionBase = base.ObtenerDescripcion();
        return $"{descripcionBase} - {NumPuertas} puertas";
    }
}</code></pre>

      <h3>Ejemplo 3: Clases <code>sealed</code> (Selladas)</h3>
      <p>Una clase sellada <code>sealed</code> no puede ser heredada. Se usa para:</p>
      <ul>
        <li>Prevenir la modificaciÃ³n de comportamiento crÃ­tico</li>
        <li>Mejorar el rendimiento (el compilador puede optimizar)</li>
        <li>Crear clases de utilidad o constantes</li>
      </ul>

      <pre><code>// Clase que NO puede ser heredada
public sealed class CalculadoraCientifica
{
    public static double Potencia(double baseNum, double exponente)
    {
        return Math.Pow(baseNum, exponente);
    }
    
    public static double LogaritmoNatural(double numero)
    {
        return Math.Log(numero);
    }
    
    public static double Factorial(int n)
    {
        if (n < 0) throw new ArgumentException("n debe ser positivo");
        if (n <= 1) return 1;
        return n * Factorial(n - 1);
    }
}

// ERROR: No se puede derivar de una clase sealed
// public class CalculadoraAvanzada : CalculadoraCientifica { }

// TambiÃ©n podemos sellar mÃ©todos individuales
public class Empleado
{
    public virtual double CalcularBono() { return 0; }
}

public class Gerente : Empleado
{
    // Este mÃ©todo ya no puede ser sobreescrito mÃ¡s
    public sealed override double CalcularBono()
    {
        return Salario * 0.20;
    }
}

// ERROR: No se puede sobreescribir un mÃ©todo sealed
// public class Director : Gerente
// {
//     public override double CalcularBono() { ... } // Â¡Error!
// }</code></pre>

      <h3>Ejemplo 4: Herencia con Interfaces</h3>
      <pre><code>// DefiniciÃ³n de interfaces
public interface IVolador
{
    void Despegar();
    void Aterrizar();
    int AlturaMaxima { get; }
}

public interface INadador
{
    void Nadar();
    int ProfundidadMaxima { get; }
}

// Clase que hereda de una clase e implementa mÃºltiples interfaces
public class Pato : Animal, IVolador, INadador
{
    public int AlturaMaxima => 1000; // metros
    public int ProfundidadMaxima => 2; // metros
    
    public override void HacerSonido()
    {
        Console.WriteLine("Â¡Cuac cuac!");
    }
    
    public void Despegar()
    {
        Console.WriteLine("El pato estÃ¡ despegando...");
    }
    
    public void Aterrizar()
    {
        Console.WriteLine("El pato estÃ¡ aterrizando en el agua...");
    }
    
    public void Nadar()
    {
        Console.WriteLine("El pato estÃ¡ nadando graciosamente.");
    }
}

// Uso polimÃ³rfico con interfaces
class Program
{
    static void Main(string[] args)
    {
        Pato pato = new Pato();
        
        // Polimorfismo con interfaces
        IVolador volador = pato;
        INadador nadador = pato;
        Animal animal = pato;
        
        volador.Despegar();      // Comportamiento de IVolador
        nadador.Nadar();          // Comportamiento de INadador
        animal.HacerSonido();     // Comportamiento de Animal
    }
}</code></pre>

      <figure>
        <img src="../assets/infografias/clase-03-herencia.png" alt="InfografÃ­a: herencia" />
        <figcaption>Diagrama de herencia simple mostrando la relaciÃ³n 'es-un' entre clases base y derivadas, con ejemplos de propiedades y mÃ©todos heredados en C#.</figcaption>
      </figure>

      <figure>
        <img src="../assets/infografias/clase-03-polimorfismo.png" alt="InfografÃ­a: polimorfismo" />
        <figcaption>IlustraciÃ³n del polimorfismo en tiempo de ejecuciÃ³n en C#, donde objetos de diferentes subclases responden al mismo mÃ©todo virtual de forma especÃ­fica.</figcaption>
      </figure>

      <div class="checklist">
        <strong>Errores Comunes a Evitar</strong>
        <ul>
          <li>No marcar mÃ©todos como <code>virtual</code> en la clase base y esperar poder sobreescribirlos</li>
          <li>Olvidar usar <code>override</code> (usar <code>new</code> por accidente cambia el comportamiento)</li>
          <li>Usar herencia donde la composiciÃ³n serÃ­a mÃ¡s apropiada (relaciÃ³n "tiene-un" vs "es-un")</li>
          <li>Romper el principio de Liskov al cambiar comportamientos de manera incompatible</li>
          <li>Olvidar llamar al constructor base con <code>base()</code> cuando es necesario</li>
          <li>Crear jerarquÃ­as demasiado profundas (mÃ¡s de 3-4 niveles es difÃ­cil de mantener)</li>
        </ul>
      </div>
    </section>

    <section id="practica">
      <h2>5. Laboratorio Guiado: Sistema de Figuras GeomÃ©tricas</h2>

      <h3>Objetivo del Laboratorio</h3>
      <p>Crear una jerarquÃ­a de clases para figuras geomÃ©tricas que demuestre herencia, polimorfismo y el uso de clases abstractas.</p>

      <div class="highlight-box">
        <h4>Tiempo Total Estimado: 40 minutos</h4>
        <ul>
          <li>ConfiguraciÃ³n del proyecto: 5 min</li>
          <li>CreaciÃ³n de clase base abstracta: 10 min</li>
          <li>ImplementaciÃ³n de subclases: 15 min</li>
          <li>Programa principal con polimorfismo: 10 min</li>
        </ul>
      </div>

      <h3>Paso 1: Crear el Proyecto (5 minutos)</h3>
      <ol>
        <li>Abre <strong>Visual Studio 2022</strong></li>
        <li>Haz clic en <strong>Crear un proyecto nuevo</strong></li>
        <li>Selecciona <strong>AplicaciÃ³n de consola</strong> (.NET 8.0)</li>
        <li>Nombra el proyecto: <code>SistemaFiguras</code></li>
        <li>Haz clic en <strong>Crear</strong></li>
      </ol>

      <h3>Paso 2: Crear la Clase Base Abstracta (10 minutos)</h3>
      <p>Crea un nuevo archivo <code>Figura.cs</code>:</p>
      <pre><code>using System;

namespace SistemaFiguras
{
    // Clase abstracta: no se puede instanciar directamente
    public abstract class Figura
    {
        // Propiedad comÃºn a todas las figuras
        public string Color { get; set; } = "Negro";
        public string Nombre { get; protected set; }
        
        // Constructor protegido
        protected Figura(string nombre)
        {
            Nombre = nombre;
        }
        
        // MÃ©todo abstracto: DEBE ser implementado por las subclases
        public abstract double CalcularArea();
        
        // MÃ©todo abstracto para perÃ­metro
        public abstract double CalcularPerimetro();
        
        // MÃ©todo virtual: puede ser sobreescrito opcionalmente
        public virtual void MostrarInfo()
        {
            Console.WriteLine($"Figura: {Nombre}");
            Console.WriteLine($"Color: {Color}");
            Console.WriteLine($"Ãrea: {CalcularArea():F2}");
            Console.WriteLine($"PerÃ­metro: {CalcularPerimetro():F2}");
        }
    }
}</code></pre>

      <h3>Paso 3: Implementar Subclases (15 minutos)</h3>
      <p>Crea <code>Rectangulo.cs</code>:</p>
      <pre><code>namespace SistemaFiguras
{
    public class Rectangulo : Figura
    {
        public double Ancho { get; set; }
        public double Alto { get; set; }
        
        public Rectangulo(double ancho, double alto) : base("RectÃ¡ngulo")
        {
            Ancho = ancho;
            Alto = alto;
        }
        
        public override double CalcularArea()
        {
            return Ancho * Alto;
        }
        
        public override double CalcularPerimetro()
        {
            return 2 * (Ancho + Alto);
        }
        
        public override void MostrarInfo()
        {
            base.MostrarInfo();
            Console.WriteLine($"Dimensiones: {Ancho} x {Alto}");
        }
    }
}</code></pre>

      <p>Crea <code>Circulo.cs</code>:</p>
      <pre><code>using System;

namespace SistemaFiguras
{
    public class Circulo : Figura
    {
        public double Radio { get; set; }
        
        public Circulo(double radio) : base("CÃ­rculo")
        {
            Radio = radio;
        }
        
        public override double CalcularArea()
        {
            return Math.PI * Radio * Radio;
        }
        
        public override double CalcularPerimetro()
        {
            return 2 * Math.PI * Radio;
        }
        
        public override void MostrarInfo()
        {
            base.MostrarInfo();
            Console.WriteLine($"Radio: {Radio}");
            Console.WriteLine($"DiÃ¡metro: {2 * Radio}");
        }
    }
}</code></pre>

      <p>Crea <code>Triangulo.cs</code> (desafÃ­o adicional):</p>
      <pre><code>using System;

namespace SistemaFiguras
{
    public class Triangulo : Figura
    {
        public double Base { get; set; }
        public double Altura { get; set; }
        public double LadoA { get; set; }
        public double LadoB { get; set; }
        public double LadoC { get; set; }
        
        public Triangulo(double baseTri, double altura, 
                         double a, double b, double c) : base("TriÃ¡ngulo")
        {
            Base = baseTri;
            Altura = altura;
            LadoA = a;
            LadoB = b;
            LadoC = c;
        }
        
        public override double CalcularArea()
        {
            return (Base * Altura) / 2;
        }
        
        public override double CalcularPerimetro()
        {
            return LadoA + LadoB + LadoC;
        }
    }
}</code></pre>

      <h3>Paso 4: Programa Principal con Polimorfismo (10 minutos)</h3>
      <p>Modifica <code>Program.cs</code>:</p>
      <pre><code>using System;
using System.Collections.Generic;

namespace SistemaFiguras
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("=== SISTEMA DE FIGURAS GEOMÃ‰TRICAS ===\n");
            
            // Lista polimÃ³rfica de figuras
            List&lt;Figura&gt; figuras = new List&lt;Figura&gt;
            {
                new Rectangulo(5, 3) { Color = "Azul" },
                new Circulo(4) { Color = "Rojo" },
                new Rectangulo(10, 2) { Color = "Verde" },
                new Triangulo(6, 4, 5, 5, 6) { Color = "Amarillo" },
                new Circulo(2.5) { Color = "Naranja" }
            };
            
            // Procesar todas las figuras polimÃ³rficamente
            double areaTotal = 0;
            foreach (Figura figura in figuras)
            {
                figura.MostrarInfo();
                areaTotal += figura.CalcularArea();
                Console.WriteLine(new string('-', 40));
            }
            
            Console.WriteLine($"\nÃREA TOTAL DE TODAS LAS FIGURAS: {areaTotal:F2}");
            
            // Demostrar polimorfismo con un mÃ©todo genÃ©rico
            Console.WriteLine("\n=== USANDO MÃ‰TODO GENÃ‰RICO ===");
            MostrarAreaDuplicada(new Circulo(3));
            MostrarAreaDuplicada(new Rectangulo(4, 5));
        }
        
        // MÃ©todo que acepta cualquier tipo de Figura
        static void MostrarAreaDuplicada(Figura figura)
        {
            Console.WriteLine($"{figura.Nombre}: Ãrea normal = {figura.CalcularArea():F2}");
            Console.WriteLine($"{figura.Nombre}: Ãrea duplicada = {figura.CalcularArea() * 2:F2}");
        }
    }
}</code></pre>

      <div class="checklist">
        <strong>Checklist de VerificaciÃ³n del Laboratorio</strong>
        <ul>
          <li>Proyecto creado correctamente en Visual Studio</li>
          <li>Clase <code>Figura</code> marcada como <code>abstract</code></li>
          <li>MÃ©todos <code>CalcularArea()</code> y <code>CalcularPerimetro()</code> marcados como <code>abstract</code></li>
          <li>Clases <code>Rectangulo</code>, <code>Circulo</code> y <code>Triangulo</code> heredan de <code>Figura</code></li>
          <li>Todas las subclases implementan los mÃ©todos abstractos</li>
          <li>Uso de <code>override</code> en lugar de <code>new</code></li>
          <li>Lista <code>List&lt;Figura&gt;</code> contiene diferentes tipos de figuras</li>
          <li>El programa calcula Ã¡reas correctamente usando polimorfismo</li>
          <li>No hay errores de compilaciÃ³n</li>
          <li>El programa ejecuta y muestra resultados correctos</li>
        </ul>
      </div>

      <div class="warning-box">
        <h4>Errores Comunes en el Laboratorio</h4>
        <ul>
          <li><strong>Error:</strong> Intentar crear <code>new Figura()</code> â†’ <strong>SoluciÃ³n:</strong> Figura es abstracta, no se instancia</li>
          <li><strong>Error:</strong> Olvidar implementar todos los mÃ©todos abstractos â†’ <strong>SoluciÃ³n:</strong> Implementar <code>CalcularArea()</code> y <code>CalcularPerimetro()</code> en cada subclase</li>
          <li><strong>Error:</strong> Usar <code>new</code> en lugar de <code>override</code> â†’ <strong>SoluciÃ³n:</strong> Siempre usar <code>override</code> para polimorfismo</li>
          <li><strong>Error:</strong> FÃ³rmula incorrecta del Ã¡rea del cÃ­rculo â†’ <strong>SoluciÃ³n:</strong> Usar <code>Math.PI * Radio * Radio</code></li>
        </ul>
      </div>
    </section>

    <section id="ejercicios">
      <h2>6. Ejercicios PrÃ¡cticos</h2>

      <h3>Ejercicio 1: JerarquÃ­a de VehÃ­culos (15 minutos)</h3>
      <div class="info-box">
        <p><strong>Objetivo:</strong> Crear una jerarquÃ­a de vehÃ­culos con al menos 3 niveles de herencia.</p>
        <p><strong>Dificultad:</strong> â­â­ Principiante</p>
      </div>

      <p><strong>Requisitos:</strong></p>
      <ol>
        <li>Crear clase base <code>Vehiculo</code> con: Marca, Modelo, AÃ±o, y mÃ©todo <code>Conducir()</code></li>
        <li>Crear <code>Auto</code> que herede de <code>Vehiculo</code> con: NÃºmero de puertas, Tipo de combustible</li>
        <li>Crear <code>Moto</code> que herede de <code>Vehiculo</code> con: Cilindraje, TieneSidecar</li>
        <li>Crear <code>AutoElectrico</code> que herede de <code>Auto</code> con: CapacidadBateria, AutonomiaKm</li>
        <li>Sobreescribir <code>Conducir()</code> en cada clase con mensaje especÃ­fico</li>
        <li>Crear un array de <code>Vehiculo[]</code> con instancias de cada tipo y recorrerlo</li>
      </ol>

      <div class="diagram">
<pre>
JERARQUÃA REQUERIDA:

              Vehiculo
             (abstract)
                  â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚                       â”‚
     Auto                   Moto
      â”‚
      â”‚
  AutoElectrico
</pre>
      </div>

      <div class="checklist">
        <strong>Checklist del Ejercicio 1</strong>
        <ul>
          <li>Clase <code>Vehiculo</code> con constructor y propiedades bÃ¡sicas</li>
          <li>MÃ©todo <code>Conducir()</code> marcado como <code>virtual</code></li>
          <li>Clases <code>Auto</code> y <code>Moto</code> heredan correctamente</li>
          <li><code>AutoElectrico</code> hereda de <code>Auto</code> (herencia multinivel)</li>
          <li>Todos los constructores usan <code>base()</code> apropiadamente</li>
          <li>Uso de <code>override</code> en los mÃ©todos sobreescritos</li>
          <li>Array polimÃ³rfico que demuestra sustituciÃ³n de Liskov</li>
          <li>Programa compila y ejecuta correctamente</li>
        </ul>
      </div>

      <h3>Ejercicio 2: Sistema de Figuras GeomÃ©tricas Avanzado (20 minutos)</h3>
      <div class="info-box">
        <p><strong>Objetivo:</strong> Extender el laboratorio con nuevas figuras y funcionalidades.</p>
        <p><strong>Dificultad:</strong> â­â­â­ Intermedio</p>
      </div>

      <p><strong>Requisitos:</strong></p>
      <ol>
        <li>Agregar clase <code>Cuadrado</code> que herede de <code>Rectangulo</code> (cumpliendo LSP)</li>
        <li>Agregar clase <code>Trapecio</code> con: BaseMayor, BaseMenor, Altura</li>
        <li>Crear interfaz <code>IDibujable</code> con mÃ©todo <code>Dibujar()</code> que imprima la figura con asteriscos</li>
        <li>Implementar <code>IDibujable</code> en <code>Rectangulo</code> y <code>Triangulo</code></li>
        <li>Agregar mÃ©todo estÃ¡tico <code>Figura CrearFiguraAleatoria()</code> que devuelva una figura aleatoria</li>
        <li>Crear lista de 10 figuras aleatorias y calcular Ã¡rea total</li>
      </ol>

      <pre><code>// Ejemplo de IDibujable para RectÃ¡ngulo 3x4:
****
****
****

// Ejemplo de IDibujable para TriÃ¡ngulo de altura 4:
   *
  ***
 *****
*******</code></pre>

      <div class="checklist">
        <strong>Checklist del Ejercicio 2</strong>
        <ul>
          <li><code>Cuadrado</code> hereda de <code>Rectangulo</code> sin romper comportamiento</li>
          <li><code>Trapecio</code> implementa correctamente <code>CalcularArea()</code></li>
          <li>Interfaz <code>IDibujable</code> definida correctamente</li>
          <li>ImplementaciÃ³n de <code>Dibujar()</code> usando ciclos anidados</li>
          <li>MÃ©todo <code>CrearFiguraAleatoria()</code> usa <code>Random</code></li>
          <li>Lista de 10 figuras generada correctamente</li>
          <li>CÃ¡lculo de Ã¡rea total funciona con todas las figuras</li>
        </ul>
      </div>

      <h3>Ejercicio 3: Sistema de Pagos con Polimorfismo (25 minutos)</h3>
      <div class="info-box">
        <p><strong>Objetivo:</strong> Crear un sistema de procesamiento de pagos que demuestre polimorfismo real.</p>
        <p><strong>Dificultad:</strong> â­â­â­â­ Avanzado</p>
      </div>

      <p><strong>Requisitos:</strong></p>
      <ol>
        <li>Crear clase abstracta <code>MetodoPago</code> con:
          <ul>
            <li>Propiedades: Titular, Monto</li>
            <li>MÃ©todo abstracto: <code>bool ProcesarPago()</code></li>
            <li>MÃ©todo abstracto: <code>string ObtenerResibo()</code></li>
            <li>MÃ©todo virtual: <code>void Validar()</code> que verifique Monto > 0</li>
          </ul>
        </li>
        <li>Crear <code>PagoTarjetaCredito</code> que herede de <code>MetodoPago</code>:
          <ul>
            <li>Propiedades: NumeroTarjeta (ocultar Ãºltimos 4 dÃ­gitos), FechaVencimiento, CVV</li>
            <li><code>ProcesarPago()</code>: Validar tarjeta no vencida, simular procesamiento</li>
            <li>Agregar comisiÃ³n del 2.5% al monto</li>
          </ul>
        </li>
        <li>Crear <code>PagoPayPal</code> que herede de <code>MetodoPago</code>:
          <ul>
            <li>Propiedades: Email, AutenticacionDosFactores</li>
            <li><code>ProcesarPago()</code>: Verificar 2FA si estÃ¡ habilitado</li>
            <li>Sin comisiÃ³n</li>
          </ul>
        </li>
        <li>Crear <code>PagoTransferenciaBancaria</code> (sellada) que herede de <code>MetodoPago</code>:
          <ul>
            <li>Propiedades: NumeroCuenta, Banco, CLABE</li>
            <li><code>ProcesarPago()</code>: Validar CLABE (18 dÃ­gitos)</li>
            <li>Agregar comisiÃ³n fija de $15</li>
          </ul>
        </li>
        <li>Crear clase <code>ProcesadorPagos</code> con mÃ©todo estÃ¡tico:
          <pre><code>public static void ProcesarMultiplesPagos(List&lt;MetodoPago&gt; pagos)</code></pre>
        </li>
        <li>Crear programa principal que simule 5 transacciones de diferentes tipos</li>
      </ol>

      <pre><code>// Estructura esperada:
MetodoPago (abstract)
    â”‚
    â”œâ”€â”€ PagoTarjetaCredito
    â”œâ”€â”€ PagoPayPal
    â””â”€â”€ PagoTransferenciaBancaria (sealed)

// Uso esperado:
var pagos = new List&lt;MetodoPago&gt;
{
    new PagoTarjetaCredito("Juan", 1000, "4111111111111111", ...),
    new PagoPayPal("Maria", 500, "maria@email.com", true),
    new PagoTransferenciaBancaria("Pedro", 2000, "012345678901234567", ...)
};

ProcesadorPagos.ProcesarMultiplesPagos(pagos);</code></pre>

      <div class="checklist">
        <strong>Checklist del Ejercicio 3</strong>
        <ul>
          <li>Clase <code>MetodoPago</code> es <code>abstract</code></li>
          <li>MÃ©todos <code>ProcesarPago()</code> y <code>ObtenerResibo()</code> son <code>abstract</code></li>
          <li>Validaciones implementadas en cada tipo de pago</li>
          <li>Ocultamiento de datos sensibles (tarjeta, CLABE)</li>
          <li>CÃ¡lculo de comisiones correcto en cada tipo</li>
          <li>Clase <code>PagoTransferenciaBancaria</code> marcada como <code>sealed</code></li>
          <li>Procesador de pagos funciona con lista polimÃ³rfica</li>
          <li>GeneraciÃ³n de recibos con formato adecuado</li>
          <li>Manejo de errores con excepciones personalizadas</li>
          <li>Programa simula transacciones correctamente</li>
        </ul>
      </div>
    </section>

    <section id="referencias">
      <h2>7. Referencias y Recursos</h2>

      <h3>DocumentaciÃ³n Oficial</h3>
      <ul>
        <li><a href="https://docs.microsoft.com/es-es/dotnet/csharp/programming-guide/classes-and-structs/inheritance" target="_blank">Microsoft Docs - Herencia en C#</a></li>
        <li><a href="https://docs.microsoft.com/es-es/dotnet/csharp/programming-guide/classes-and-structs/polymorphism" target="_blank">Microsoft Docs - Polimorfismo en C#</a></li>
        <li><a href="https://docs.microsoft.com/es-es/dotnet/csharp/language-reference/keywords/base" target="_blank">Palabra clave base (C#)</a></li>
        <li><a href="https://docs.microsoft.com/es-es/dotnet/csharp/language-reference/keywords/sealed" target="_blank">Palabra clave sealed (C#)</a></li>
      </ul>

      <h3>Libros Recomendados</h3>
      <ul>
        <li><em>"C# 10 in a Nutshell"</em> - Joseph Albahari (CapÃ­tulos 3 y 6)</li>
        <li><em>"Head First Design Patterns"</em> - Eric Freeman (Patrones con herencia)</li>
        <li><em>"Clean Code"</em> - Robert C. Martin (CapÃ­tulo sobre herencia vs composiciÃ³n)</li>
      </ul>

      <h3>Recursos Online</h3>
      <ul>
        <li><a href="https://refactoring.guru/es/design-patterns" target="_blank">Refactoring Guru - Patrones de DiseÃ±o</a></li>
        <li><a href="https://www.csharptutorial.net/csharp-oop/" target="_blank">C# Tutorial - OOP en C#</a></li>
        <li><a href="https://www.tutorialsteacher.com/csharp/csharp-inheritance" target="_blank">TutorialsTeacher - Herencia C#</a></li>
      </ul>

      <h3>Videos Relacionados</h3>
      <ul>
        <li>Canal de YouTube: <em>"DotNet"</em> - Serie de POO en C#</li>
        <li>Platzi: Curso de ProgramaciÃ³n Orientada a Objetos con C#</li>
      </ul>

      <div class="highlight-box">
        <h4>PrÃ³xima Clase: Clase 04 - Interfaces y Clases Abstractas</h4>
        <p>En la prÃ³xima clase profundizaremos en:</p>
        <ul>
          <li>Diferencias entre interfaces y clases abstractas</li>
          <li>ImplementaciÃ³n explÃ­cita de interfaces</li>
          <li>Herencia mÃºltiple de interfaces</li>
          <li>Patrones de diseÃ±o: Strategy, Repository</li>
        </ul>
      </div>
    </section>

  </main>

  <footer>
    <p><strong>IF0100 - Lenguaje de ProgramaciÃ³n Orientada a Objetos II</strong></p>
    <p>UNAULA - IngenierÃ­a InformÃ¡tica - 2026-I</p>
    <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">Clase 03 - Herencia y Polimorfismo</p>
  </footer>
</body>
</html>
