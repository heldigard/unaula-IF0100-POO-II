<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Aprende herencia y polimorfismo en Python POO. Domina super(), override, clases base y derivadas. Implementa User Admin y RegularUser para TaskFlow.">
    <meta name="author" content="IF0100 - UNAULA">
    <title>Herencia y Polimorfismo | IF0100 - POO II</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
          crossorigin="anonymous">

    <!-- Prism.js para syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
          rel="stylesheet">

    <style>
        :root {
            --primary-color: #0d6efd;
            --secondary-color: #6c757d;
            --success-color: #198754;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #0dcaf0;
            --light-bg: #f8f9fa;
            --dark-text: #212529;
            --border-color: #dee2e6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.7;
            color: var(--dark-text);
        }

        header {
            background: linear-gradient(135deg, var(--primary-color) 0%, #0a58ca 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        header h2 {
            font-size: 1.25rem;
            font-weight: 400;
            opacity: 0.9;
        }

        header h3 {
            font-size: 1rem;
            font-weight: 300;
            opacity: 0.8;
        }

        .navbar {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .sidebar {
            background-color: var(--light-bg);
            border-radius: 8px;
            padding: 1.5rem;
            position: sticky;
            top: 2rem;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .sidebar h5 {
            color: var(--primary-color);
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary-color);
        }

        .sidebar ul {
            list-style: none;
            padding-left: 0;
        }

        .sidebar li {
            margin-bottom: 0.5rem;
        }

        .sidebar a {
            color: var(--dark-text);
            text-decoration: none;
            padding: 0.5rem 0.75rem;
            display: block;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .sidebar a:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateX(5px);
        }

        main {
            padding: 2rem 0;
        }

        section {
            margin-bottom: 3rem;
            padding: 1.5rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        section h2 {
            color: var(--primary-color);
            font-weight: 600;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 3px solid var(--primary-color);
        }

        section h3 {
            color: var(--dark-text);
            font-weight: 500;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
        }

        section h4 {
            color: var(--secondary-color);
            font-weight: 500;
            margin-top: 1rem;
            margin-bottom: 0.75rem;
        }

        section ul, section ol {
            padding-left: 1.5rem;
            margin-bottom: 1rem;
        }

        section li {
            margin-bottom: 0.5rem;
        }

        pre[class*="language-"] {
            border-radius: 6px;
            margin: 1rem 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        code[class*="language-"] {
            font-size: 0.9rem;
        }

        .alert-note {
            background-color: #e7f3ff;
            border-left: 4px solid var(--info-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .alert-warning-custom {
            background-color: #fff3cd;
            border-left: 4px solid var(--warning-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .alert-tip {
            background-color: #d1e7dd;
            border-left: 4px solid var(--success-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .alert-error {
            background-color: #f8d7da;
            border-left: 4px solid var(--danger-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .card {
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .table {
            margin: 1rem 0;
        }

        .table thead {
            background-color: var(--primary-color);
            color: white;
        }

        footer {
            background-color: var(--light-bg);
            padding: 2rem 0;
            margin-top: 3rem;
            text-align: center;
            border-top: 1px solid var(--border-color);
        }

        footer p {
            margin-bottom: 0.5rem;
            color: var(--secondary-color);
        }

        @media print {
            header {
                background: white !important;
                color: black !important;
                padding: 1rem 0;
            }

            .navbar, .sidebar, footer {
                display: none;
            }

            section {
                page-break-inside: avoid;
                box-shadow: none;
                border: 1px solid var(--border-color);
            }

            a {
                color: black;
                text-decoration: none;
            }

            a[href]:after {
                content: " (" attr(href) ")";
            }
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.5rem;
            }

            header h2 {
                font-size: 1rem;
            }

            .sidebar {
                position: static;
                max-height: none;
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>IF0100 - Lenguaje de Programación OO II</h1>
            <h2>Unidad 1: Programación Orientada a Objetos</h2>
            <h3>Clase 3: Herencia y Polimorfismo</h3>
        </div>
    </header>

    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                    data-bs-target="#navbarNav"
                    aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html">Inicio</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="clase-02-encapsulamiento.html">Anterior: Encapsulamiento</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="clase-04-sobrecarga-sobreescritura.html">Siguiente: Sobrecarga y Sobreescritura</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="row">
            <aside class="col-lg-3">
                <nav class="sidebar">
                    <h5>Contenido</h5>
                    <ul>
                        <li><a href="#objetivos">Objetivos de Aprendizaje</a></li>
                        <li><a href="#teoria">Conceptos Teóricos</a></li>
                        <li><a href="#ejemplos">Ejemplos Prácticos</a></li>
                        <li><a href="#buenas-practicas">Buenas Prácticas</a></li>
                        <li><a href="#ejercicio">Ejercicio Guiado</a></li>
                        <li><a href="#referencias">Para Profundizar</a></li>
                        <li><a href="#taskflow">Conexión con TaskFlow</a></li>
                    </ul>
                </nav>
            </aside>

            <main class="col-lg-9">
                <section id="objetivos">
                    <h2>Objetivos de Aprendizaje</h2>
                    <p>Al finalizar esta clase, usted será capaz de:</p>
                    <ul>
                        <li>Comprender el concepto de herencia en POO y su importancia</li>
                        <li>Implementar herencia de clases en Python (herencia simple y múltiple)</li>
                        <li>Aplicar el principio de polimorfismo en código real</li>
                        <li>Utilizar <code>super()</code> correctamente para llamar métodos de la clase padre</li>
                        <li>Distinguir entre sobreescritura (override) y sobrecarga (overload)</li>
                        <li>Aplicar herencia al proyecto TaskFlow (User → AdminUser, RegularUser)</li>
                        <li>Decidir cuándo usar herencia vs composición</li>
                    </ul>
                </section>

                <section id="teoria">
                    <h2>Conceptos Teóricos</h2>

                    <h3>¿Qué es la Herencia?</h3>
                    <p>La <strong>herencia</strong> es uno de los pilares fundamentales de la POO que permite crear nuevas clases basadas en clases existentes. La clase existente se denomina <strong>clase padre, base o superclase</strong>, y la nueva clase se llama <strong>clase hija, derivada o subclase</strong>.</p>
                    <p>La herencia establece una relación "es-un" (is-a) entre las clases:</p>

                    <div class="alert-note">
                        <strong>Analogia:</strong> Piensa en la herencia como en la biologica. Un Perro hereda características de Animal (nombre, edad, comer()) pero también tiene sus propias características específicas (ladrar(), morder()). De igual manera, un Gato hereda de Animal pero implementa maullar().
                    </div>

                    <pre><code class="language-python"># Clase padre (superclase)
class Animal:
    """Clase base que representa un animal."""

    def __init__(self, nombre: str, edad: int):
        self.nombre = nombre
        self.edad = edad

    def comer(self) -> str:
        """Método que todas las subclases heredan."""
        return f"{self.nombre} está comiendo."

    def emitir_sonido(self) -> str:
        """Método que las subclases sobreescribirán."""
        return "Sonido genérico de animal"


# Clase hija (subclase)
class Perro(Animal):
    """Perro hereda de Animal."""

    def __init__(self, nombre: str, raza: str):
        # super() llama al __init__ de la clase padre
        super().__init__(nombre, edad)
        self.raza = raza

    def emitir_sonido(self) -> str:
        # Override: sobreescribe el comportamiento del padre
        return "Guau guau!"

    def ladrar(self) -> str:
        """Método específico de Perro."""
        return f"{self.nombre} está ladrando."


# Uso
perro = Perro("Fido", "Golden Retriever")
print(perro.comer())         # Heredado de Animal: Fido está comiendo.
print(perro.emitir_sonido()) # Sobreescrito en Perro: Guau guau!
print(perro.ladrar())        # Específico de Perro: Fido está ladrando.</code></pre>

                    <h3>Herencia Simple vs Múltiple</h3>
                    <p>Python soporta tanto herencia simple como múltiple:</p>

                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Tipo</th>
                                <th>Descripcion</th>
                                <th>Ejemplo</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Herencia Simple</strong></td>
                                <td>Una sola clase padre</td>
                                <td><code>class Perro(Animal)</code></td>
                            </tr>
                            <tr>
                                <td><strong>Herencia Multiple</strong></td>
                                <td>Multiple clases padre</td>
                                <td><code>class Clase(A, B, C)</code></td>
                            </tr>
                        </tbody>
                    </table>

                    <pre><code class="language-python"># Herencia multiple
class Volador:
    """Clase que define comportamiento de vuelo."""
    def volar(self) -> str:
        return "Volando..."


class Nadador:
    """Clase que define comportamiento de natacion."""
    def nadar(self) -> str:
        return "Nadando..."


class Pato(Volador, Nadador):
    """Pato hereda de Volador y Nadador (MRO: Method Resolution Order)."""
    def __init__(self, nombre: str):
        self.nombre = nombre

    def presentar(self) -> str:
        return f"Soy {self.nombre} y puedo:"


pato = Pato("Donald")
print(pato.presentar())
print(f"  - {pato.volar()}")   # Heredado de Volador
print(f"  - {pato.nadar()}")   # Heredado de Nadador

# Ver MRO (Method Resolution Order)
print("\nOrden de resolucion de metodos (MRO):")
for cls in Pato.__mro__:
    print(f"  - {cls.__name__}")</code></pre>

                    <div class="alert-warning-custom">
                        <strong>Nota sobre MRO:</strong> Python usa el algoritmo C3 para determinar el orden de busqueda de metodos en herencia multiple. Puedes verificarlo con <code>Clase.__mro__</code> o <code>Clase.mro()</code>.
                    </div>

                    <h3>La Clase Base object</h3>
                    <p>En Python 3, todas las clases heredan implicitamente de <code>object</code> si no se especifica otra clase padre. Esto proporciona los metodos especiales basicos como <code>__str__</code>, <code>__repr__</code>, etc.</p>

                    <pre><code class="language-python"># Equivalentes en Python 3
class MiClase:
    pass

class MiClase(object):
    pass

# Ambas son identicas porque Python 3 hace que hereden de object implicitamente

# Verificar la jerarquia
print(MiClase.__mro__)
# Salida: (&lt;class '__main__.MiClase'>, &lt;class 'object'>)</code></pre>

                    <h3>Constructores en Herencia (super())</h3>
                    <p>La funcion <code>super()</code> permite llamar metodos de la clase padre de manera segura, especialmente util en herencia multiple.</p>

                    <pre><code class="language-python">class Persona:
    """Clase base Persona."""

    def __init__(self, nombre: str, edad: int):
        self.nombre = nombre
        self.edad = edad
        print(f"  [Persona __init__] Creando: {nombre}")

    def presentar(self) -> str:
        return f"Soy {self.nombre}, tengo {self.edad} años"


class Empleado(Persona):
    """Empleado hereda de Persona."""

    def __init__(self, nombre: str, edad: int, salario: float):
        # Llamar al __init__ del padre
        super().__init__(nombre, edad)
        self.salario = salario
        print(f"  [Empleado __init__] Salario: ${salario}")

    def presentar(self) -> str:
        # Llamar al metodo del padre y extenderlo
        base = super().presentar()
        return f"{base} y gano ${self.salario}"


# Crear instancias
print("=== Creando Persona ===")
persona = Persona("Ana", 30)
print(persona.presentar())

print("\n=== Creando Empleado ===")
empleado = Empleado("Carlos", 25, 50000)
print(empleado.presentar())</code></pre>

                    <h4>super() sin argumentos (Python 3)</h4>
                    <pre><code class="language-python"># Python 3 permite super() sin argumentos
class ClaseHija(ClasePadre):
    def metodo(self):
        # Equivalente a super().metodo() en Python 3
        return super().metodo() + " extendida"

# Anterior a Python 2, debias usar: super(ClaseHija, self).metodo()</code></pre>

                    <h3>Sobreescritura de Metodos (Override)</h3>
                    <p>La <strong>sobreescritura</strong> (override) ocurre cuando una subclase proporciona una implementacion diferente de un metodo que ya existe en la clase padre.</p>

                    <pre><code class="language-python">class Vehiculo:
    """Clase base de vehiculos."""

    def __init__(self, marca: str, modelo: str):
        self.marca = marca
        self.modelo = modelo

    def describir(self) -> str:
        """Descripcion basica."""
        return f"{self.marca} {self.modelo}"

    def mover(self) -> str:
        """Comportamiento generico de movimiento."""
        return "El vehiculo se esta moviendo"


class Coche(Vehiculo):
    """Coche sobreescribe comportamientos de Vehiculo."""

    def __init__(self, marca: str, modelo: str, num_puertas: int):
        super().__init__(marca, modelo)
        self.num_puertas = num_puertas

    def describir(self) -> str:
        """Override: descripcion personalizada para Coche."""
        return f"{super().describir()} ({self.num_puertas} puertas)"

    def mover(self) -> str:
        """Override: comportamiento especifico."""
        return "El coche esta conducirdo por la carretera"


class Bicicleta(Vehiculo):
    """Bicicleta sobreescribe comportamientos de Vehiculo."""

    def mover(self) -> str:
        """Override: comportamiento especifico."""
        return "La bicicleta esta pedaleando"


# Polimorfismo en accion
vehiculos = [
    Coche("Toyota", "Corolla", 4),
    Bicicleta("Trek", "FX")
]

for vehiculo in vehiculos:
    print(f"Descripcion: {vehiculo.describir()}")
    print(f"Movimiento: {vehiculo.mover()}")
    print("-" * 40)</code></pre>

                    <h3>Polimorfismo en Python</h3>
                    <p>El <strong>polimorfismo</strong> permite que objetos de diferentes clases sean tratados de la misma manera a través de una interfaz común. Python aplica polimorfismo de forma natural gracias al "duck typing".</p>

                    <div class="alert-note">
                        <strong>Principio Duck Typing:</strong> "Si camina como un pato y grazna como un pato, entonces es un pato". En Python, lo que importa es que un objeto tenga los metodos necesarios, no su tipo exacto.
                    </div>

                    <pre><code class="language-python">class Pato:
    def graznar(self) -> str:
        return "Cuac cuac!"


class Ganso:
    def graznar(self) -> str:
        return " graznido de ganso!"


class Persona:
    def graznar(self) -> str:
        return "La persona imita: cuac!"


# Polimorfismo: todos tienen el metodo graznar()
animales: list[Pato | Ganso | Persona] = [Pato(), Ganso(), Persona()]

for animal in animales:
    print(animal.graznar())
# Salida:
# Cuac cuac!
# graznido de ganso!
# La persona imita: cuac!</code></pre>

                    <h3>Polimorfismo con Funciones</h3>
                    <pre><code class="language-python">def hacer_sonar(animal):
    """Funcion polimorfica que acepta cualquier objeto con metodo graznar()."""
    print(f"El animal hace: {animal.graznar()}")


# Diferentes tipos, misma interfaz
hacer_sonar(Pato())       # El animal hace: Cuac cuac!
hacer_sonar(Ganso())      # El animal hace: graznido de ganso!
hacer_sonar(Persona())    # El animal hace: La persona imita: cuac!</code></pre>

                    <h3>Herencia vs Composicion</h3>
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Aspecto</th>
                                <th>Herencia</th>
                                <th>Composicion</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Relacion</strong></td>
                                <td>"Es-un" (is-a)</td>
                                <td>"Tiene-un" (has-a)</td>
                            </tr>
                            <tr>
                                <td><strong>Acoplamiento</strong></td>
                                <td>Alto (clase hija depende del padre)</td>
                                <td>Bajo (componentes independientes)</td>
                            </tr>
                            <tr>
                                <td><strong>Flexibilidad</strong></td>
                                <td>Menos flexible (jerarquia rigida)</td>
                                <td>Mas flexible (combinar comportamientos)</td>
                            </tr>
                            <tr>
                                <td><strong>Ejemplo</strong></td>
                                <td>Perro es un Animal</td>
                                <td>Coche tiene un Motor</td>
                            </tr>
                        </tbody>
                    </table>

                    <pre><code class="language-python"># HERENCIA: "Es-un"
class Animal:
    def __init__(self, nombre: str):
        self.nombre = nombre

    def respirar(self) -> str:
        return f"{self.nombre} respira"


class Perro(Animal):
    def ladrar(self) -> str:
        return f"{self.nombre} ladra"


# COMPOSICION: "Tiene-un"
class Motor:
    def iniciar(self) -> str:
        return "Motor iniciado"

    def detener(self) -> str:
        return "Motor detenido"


class Coche:
    """Coche TIENE un Motor (composicion)."""
    def __init__(self, marca: str):
        self.marca = marca
        self.motor = Motor()  # Componte

    def conducir(self) -> str:
        self.motor.iniciar()
        return f"{self.marca} conduciendo"

    def estacionar(self) -> str:
        self.motor.detener()
        return f"{self.marca} estacionado"</code></pre>

                    <div class="alert-tip">
                        <strong>Regla de Oro:</strong> "Favor composition over inheritance" (Preferir composicion sobre herencia). Usa herencia cuando exista una verdadera relacion "es-un" clara, de lo contrario, usa composicion.
                    </div>

                    <h3>Clases Abstractas (Preview)</h3>
                    <p>Las <strong>clases abstractas</strong> son clases que no pueden ser instanciadas directamente y sirven como plantillas para otras clases. Se definen usando el modulo <code>abc</code>.</p>

                    <div class="alert-note">
                        <strong>Preview:</strong> En la proxima clase profundizaremos en clases abstractas e interfaces. Por ahora, conocemos su existencia y proposito.
                    </div>

                    <pre><code class="language-python">from abc import ABC, abstractmethod


class Figura(ABC):
    """Clase abstracta para figuras geometricas."""

    @abstractmethod
    def area(self) -> float:
        """Metodo abstracto: debe ser implementado por subclases."""
        pass

    @abstractmethod
    def perimetro(self) -> float:
        """Metodo abstracto: debe ser implementado por subclases."""
        pass


# No se puede instanciar directamente:
# figura = Figura()  # ERROR: Can't instantiate abstract class

class Cuadrado(Figura):
    """Cuadrado implementa los metodos abstractos."""

    def __init__(self, lado: float):
        self.lado = lado

    def area(self) -> float:
        return self.lado ** 2

    def perimetro(self) -> float:
        return 4 * self.lado


# Ahora si podemos crear instancias
cuadrado = Cuadrado(5)
print(f"Area: {cuadrado.area()}")       # 25
print(f"Perimetro: {cuadrado.perimetro()}")  # 20</code></pre>
                </section>

                <section id="ejemplos">
                    <h2>Ejemplos Practicos</h2>

                    <h3>Ejemplo 1: Sistema de Empleados con Herencia</h3>
                    <pre><code class="language-python">"""
Sistema de empleados con herencia jerarquica.
"""


class Empleado:
    """Clase base para todos los empleados."""

    # Atributo de clase
    incremento_salario = 1.05  # 5% de incremento anual

    def __init__(self, nombre: str, email: str, salario_base: float):
        self.nombre = nombre
        self.email = email
        self.salario_base = salario_base

    def __str__(self) -> str:
        return f"{self.__class__.__name__}: {self.nombre}"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(nombre='{self.nombre}', salario={self.salario_base})"

    def calcular_salario_mensual(self) -> float:
        """Salario mensual basico."""
        return self.salario_base

    def obtener_info(self) -> str:
        """Informacion basica del empleado."""
        return f"{self.nombre} - {self.email} - ${self.calcular_salario_mensual():,.2f}"


class EmpleadoTiempoCompleto(Empleado):
    """Empleado con salario mensual fijo + beneficios."""

    def __init__(self, nombre: str, email: str, salario_base: float, bono_mensual: float):
        super().__init__(nombre, email, salario_base)
        self.bono_mensual = bono_mensual

    def calcular_salario_mensual(self) -> float:
        """Override: salario + bono."""
        return super().calcular_salario_mensual() + self.bono_mensual


class EmpleadoPorHoras(Empleado):
    """Empleado con pago por horas trabajadas."""

    def __init__(self, nombre: str, email: str, tarifa_hora: float, horas_mes: int):
        super().__init__(nombre, email, 0)  # No tiene salario base
        self.tarifa_hora = tarifa_hora
        self.horas_mes = horas_mes

    def calcular_salario_mensual(self) -> float:
        """Override: tarifa * horas."""
        return self.tarifa_hora * self.horas_mes


class EmpleadoComision(Empleado):
    """Empleado con salario base + comision por ventas."""

    def __init__(self, nombre: str, email: str, salario_base: float, porcentaje_comision: float):
        super().__init__(nombre, email, salario_base)
        self.porcentaje_comision = porcentaje_comision
        self.ventas_mes = 0.0

    def registrar_venta(self, monto: float) -> None:
        """Registrar una venta."""
        self.ventas_mes += monto

    def calcular_salario_mensual(self) -> float:
        """Override: salario base + comision."""
        return self.salario_base + (self.ventas_mes * self.porcentaje_comision)


# Uso del sistema
print("=== Sistema de Empleados ===\n")

# Lista polimorfica
empleados: list[Empleado] = [
    EmpleadoTiempoCompleto("Juan Perez", "juan@empresa.com", 3000, 500),
    EmpleadoPorHoras("Maria Garcia", "maria@empresa.com", 25, 160),
    EmpleadoComision("Carlos Lopez", "carlos@empresa.com", 2000, 0.10)
]

# Registrar algunas ventas para el empleado por comision
empleados[2].registrar_venta(5000)
empleados[2].registrar_vista(3000)

# Polimorfismo en accion
for emp in empleados:
    print(emp.obtener_info())
    print(f"   Salario mensual: ${emp.calcular_salario_mensual():,.2f}\n")

# Comparar tipos
print("=== Tipos de empleados ===")
for emp in empleados:
    print(f"{emp.nombre}: {type(emp).__name__}")</code></pre>

                    <h3>Ejemplo 2: Jerarquia de Vehiculos</h3>
                    <pre><code class="language-python">"""
Jerarquia de vehiculos con herencia multiple.
"""


class Serializable:
    """Capacidad de serializar a JSON."""

    def to_json(self) -> str:
        import json
        return json.dumps(self.__dict__)


class Deserializable:
    """Capacidad de deserializar desde JSON."""

    @classmethod
    def from_json(cls, json_str: str) -> "Deserializable":
        import json
        data = json.loads(json_str)
        return cls(**data)


class Vehiculo(Serializable):
    """Clase base para todos los vehiculos."""

    def __init__(self, marca: str, modelo: str, año: int):
        self.marca = marca
        self.modelo = modelo
        self.año = año

    def __str__(self) -> str:
        return f"{self.año} {self.marca} {self.modelo}"

    def describir(self) -> str:
        return f"Vehiculo: {self}"


class VehiculoTerrestre(Vehiculo):
    """Vehiculo que se mueve por tierra."""

    def __init__(self, marca: str, modelo: str, año: int, num_ruedas: int):
        super().__init__(marca, modelo, año)
        self.num_ruedas = num_ruedas

    def mover(self) -> str:
        return f"El vehiculo transita por la carretera"


class VehiculoAcuatico(Vehiculo):
    """Vehiculo que se mueve por agua."""

    def __init__(self, marca: str, modelo: str, año: int, eslora: float):
        super().__init__(marca, modelo, año)
        self.eslora = eslora  # Longitud en metros

    def mover(self) -> str:
        return "El vehiculo navega por el agua"


class VehiculoAereo(Vehiculo):
    """Vehiculo que vuela."""

    def __init__(self, marca: str, modelo: str, año: int, altitud_max: int):
        super().__init__(marca, modelo, año)
        self.altitud_max = altitud_max

    def mover(self) -> str:
        return f"El vehiculo vuela a {self.altitud_max}m de altitud"


# Herencia multiple: terrestres + serializables
class Coche(VehiculoTerrestre, Deserializable):
    """Coche - terrestre y deserializable."""

    def __init__(self, marca: str, modelo: str, año: int, num_ruedas: int, tipo_combustible: str):
        super().__init__(marca, modelo, año, num_ruedas)
        self.tipo_combustible = tipo_combustible

    def mover(self) -> str:
        return f"El coche conduce ({self.tipo_combustible})"


class Barco(VehiculoAcuatico, Deserializable):
    """Barco - acuatico y deserializable."""

    def __init__(self, marca: str, modelo: str, año: int, eslora: int, capacidad: int):
        super().__init__(marca, modelo, año, eslora)
        self.capacidad = capacidad

    def mover(self) -> str:
        return f"El barco navega (capacidad: {self.capacidad} personas)"


# Uso
print("=== Jerarquia de Vehiculos ===\n")

vehiculos = [
    Coche("Toyota", "Corolla", 2023, 4, "Gasolina"),
    Barco("Yamaha", "242X", 2022, 7, 12)
]

for v in vehiculos:
    print(f"Tipo: {type(v).__name__}")
    print(f"Descripcion: {v.describir()}")
    print(f"Movimiento: {v.mover()}")

    # Serializacion
    json_str = v.to_json()
    print(f"JSON: {json_str}\n")</code></pre>

                    <h3>Ejemplo 3: TaskFlow - Clase Base User y Subclases</h3>
                    <pre><code class="language-python">"""
TaskFlow - Sistema de usuarios con herencia.
User como clase base, AdminUser y RegularUser como subclases.
"""


from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional
from enum import Enum


class RolUsuario(Enum):
    """Roles disponibles en el sistema."""
    ADMIN = "admin"
    REGULAR = "regular"
    VISITANTE = "visitante"


class EstadoUsuario(Enum):
    """Estados posibles de un usuario."""
    ACTIVO = "activo"
    INACTIVO = "inactivo"
    BLOQUEADO = "bloqueado"


@dataclass
class User:
    """Clase base para todos los usuarios del sistema TaskFlow.

    Attributes:
        id: Identificador unico del usuario.
        username: Nombre de usuario unico.
        email: Correo electronico.
        rol: Rol del usuario en el sistema.
        estado: Estado actual del usuario.
        creado_en: Fecha de creacion.
        ultimo_acceso: Ultimo acceso al sistema.
    """

    username: str
    email: str
    rol: RolUsuario
    id: Optional[int] = None
    estado: EstadoUsuario = EstadoUsuario.ACTIVO
    creado_en: Optional[datetime] = None
    ultimo_acceso: Optional[datetime] = None

    def __post_init__(self):
        if self.creado_en is None:
            self.creado_en = datetime.now()

    def __str__(self) -> str:
        return f"[{self.rol.value}] {self.username}"

    def __repr__(self) -> str:
        return (f"User(id={self.id}, username='{self.username}', "
                f"rol={self.rol.value}, estado={self.estado.value})")

    # ============================================
    # Metodos heredados por todas las subclases
    # ============================================

    def esta_activo(self) -> bool:
        """Verifica si el usuario esta activo."""
        return self.estado == EstadoUsuario.ACTIVO

    def registrar_acceso(self) -> None:
        """Registra el acceso al sistema."""
        self.ultimo_acceso = datetime.now()

    def tiene_permiso(self, permiso: str) -> bool:
        """Verifica si tiene un permiso basico."""
        # Por defecto, solo los activos tienen permisos basicos
        return self.esta_activo()

    def to_dict(self) -> dict:
        """Convierte a diccionario."""
        return {
            "id": self.id,
            "username": self.username,
            "email": self.email,
            "rol": self.rol.value,
            "estado": self.estado.value,
            "creado_en": self.creado_en.isoformat() if self.creado_en else None,
            "ultimo_acceso": self.ultimo_acceso.isoformat() if self.ultimo_acceso else None
        }


@dataclass
class RegularUser(User):
    """Usuario regular con permisos basicos."""

    tareas_asignadas: int = 0
    tareas_completadas: int = 0

    def __post_init__(self):
        super().__post_init__()
        self.rol = RolUsuario.REGULAR

    def tiene_permiso(self, permiso: str) -> bool:
        """Override: permisos limitados para usuarios regulares."""
        permisos_permitidos = ["ver_tareas", "crear_tareas", "completar_tareas"]
        return super().tiene_permiso(permiso) and permiso in permisos_permitidos

    def estadisticas(self) -> dict:
        """Estadisticas del usuario."""
        total = self.tareas_asignadas
        completadas = self.tareas_completadas
        return {
            "total": total,
            "completadas": completadas,
            "pendientes": total - completadas,
            "porcentaje": (completadas / total * 100) if total > 0 else 0
        }


@dataclass
class AdminUser(User):
    """Administrador con todos los permisos."""

    usuarios_bloqueados: int = 0
    sistema_auditoria: bool = True

    def __post_init__(self):
        super().__post_init__()
        self.rol = RolUsuario.ADMIN

    def tiene_permiso(self, permiso: str) -> bool:
        """Override: administradores tienen todos los permisos."""
        # Si esta activo, tiene todos los permisos
        return self.esta_activo()

    def bloquear_usuario(self, usuario: User) -> str:
        """Bloquea un usuario del sistema."""
        usuario.estado = EstadoUsuario.BLOQUEADO
        self.usuarios_bloqueados += 1
        return f"Usuario {usuario.username} bloqueado"

    def ver_estadisticas_sistema(self) -> dict:
        """Estadisticas globales del sistema (simulado)."""
        return {
            "usuarios_bloqueados": self.usuarios_bloqueados,
            "auditoria_activa": self.sistema_auditoria,
            "estado": "Operativo"
        }


# ============================================
# USO DEL SISTEMA
# ============================================

if __name__ == "__main__":
    print("=== TaskFlow - Sistema de Usuarios ===\n")

    # Crear usuarios
    admin = AdminUser(
        username="admin_master",
        email="admin@taskflow.com",
        rol=RolUsuario.ADMIN
    )

    regular1 = RegularUser(
        username="juan_dev",
        email="juan@taskflow.com",
        rol=RolUsuario.REGULAR
    )
    regular1.tareas_asignadas = 10
    regular1.tareas_completadas = 7

    regular2 = RegularUser(
        username="maria_design",
        email="maria@taskflow.com",
        rol=RolUsuario.REGULAR
    )

    usuarios: list[User] = [admin, regular1, regular2]

    # Polimorfismo: misma interfaz para todos
    print("=== Usuarios en el sistema ===")
    for usuario in usuarios:
        print(f"\n{usuario}")
        print(f"   Tipo: {type(usuario).__name__}")
        print(f"   Activo: {usuario.esta_activo()}")
        print(f"   Permiso 'crear_tareas': {usuario.tiene_permiso('crear_tareas')}")
        print(f"   Permiso 'eliminar_usuarios': {usuario.tiene_permiso('eliminar_usuarios')}")

        # Metodos especificos de subclases
        if isinstance(usuario, RegularUser):
            stats = usuario.estadisticas()
            print(f"   Tareas: {stats['completadas']}/{stats['total']} ({stats['porcentaje']:.1f}%)")
        elif isinstance(usuario, AdminUser):
            stats = usuario.ver_estadisticas_sistema()
            print(f"   Sistema: {stats['estado']}")

    # Admin bloquea a un usuario
    print("\n=== Accion de Administrador ===")
    resultado = admin.bloquear_usuario(regular2)
    print(resultado)
    print(f"Estado de {regular2.username}: {regular2.estado.value}")

    print("\n=== Resumen ===")
    print(f"Total usuarios: {len(usuarios)}")
    print(f"Admin: {admin.username}")
    print(f"Usuarios regulares: {len([u for u in usuarios if isinstance(u, RegularUser)])}")</code></pre>
                </section>

                <section id="buenas-practicas">
                    <h2>Buenas Practicas</h2>

                    <h3>Favor Composition over Inheritance</h3>
                    <pre><code class="language-python"># ❌ Evitar: Herencia profunda/incorrecta
class AudioBook(Libro, Reproducible, Descargable, Comprimible):
    # Jerarquia confusa y fragil
    pass

# ✅ Preferir: Composicion con interfaces claras
class AudioBook:
    def __init__(self, titulo: str, reproductor: Reproducible, descargador: Descargable):
        self.titulo = titulo
        self.reproductor = reproductor  # Componente
        self.descargador = descargador  # Componente

    def reproducir(self):
        return self.reproductor.reproducir()

    def descargar(self):
        return self.descargador.descargar()</code></pre>

                    <h3>Cuando Usar Herencia</h3>
                    <pre><code class="language-python"># ✅ Bien: Herencia cuando existe "es-un" verdadera
class Shape:  # ABC - asegura implementacion de metodos
    @abstractmethod
    def area(self) -> float:
        pass

class Circle(Shape):  # "Circle es-un Shape"
    def __init__(self, radio: float):
        self.radio = radio

    def area(self) -> float:  # Override obligatorio
        return 3.14159 * self.radio ** 2

# ❌ Evitar: Herencia por conveniencia
class DatabaseModel(User):  # "DatabaseModel NO es-un User"
    # Esto esta mal conceptualizado
    pass</code></pre>

                    <h3>Uso Correcto de super()</h3>
                    <pre><code class="language-python"># ✅ Bien: super() en __init__
class Padre:
    def __init__(self, nombre: str):
        self.nombre = nombre

class Hijo(Padre):
    def __init__(self, nombre: str, edad: int):
        super().__init__(nombre)  # Llama al __init__ del padre
        self.edad = edad

# ✅ Bien: super() en metodos
class Animal:
    def hacer_sonido(self) -> str:
        return "Sonido"

class Perro(Animal):
    def hacer_sonido(self) -> str:
        base = super().hacer_sonido()
        return f"{base} + Guau!"  # Extiende, no reemplaza

# ❌ Evitar: super() sin argumentos en Python 2
# class Hijo(Padre):
#     def __init__(self, nombre):
#         super(Hijo, self).__init__(nombre)  # Python 2 style, obsoleto</code></pre>

                    <h3>Nombres de Clases</h3>
                    <pre><code class="language-python"># ✅ Bien: Nombres descriptivos en PascalCase
class TaskManager:
    """Gestiona tareas del sistema."""


class UserAuthentication:
    """Maneja autenticacion de usuarios."""


class DatabaseConnectionPool:
    """Pool de conexiones a base de datos."""


# ❌ Evitar: Nombres confusos o inconsistentes
class manager:  # Debe ser PascalCase
    pass

class userAuth:  # Mezcla de estilos
    pass

class DB_pool:  # snake_case para clases
    pass</code></pre>

                    <h3>Documentar la Herencia</h3>
                    <pre><code class="language-python">class BaseValidator:
    """Clase base para validadores.

    Subclasses must implement:
        validate(data: dict) -> bool: Valida los datos.
        get_errors() -> list[str]: Retorna errores de validacion.
    """


class EmailValidator(BaseValidator):
    """Validador de direcciones de email.

    Hereda de:
        BaseValidator: Interfaz comun para todos los validadores.

    Example:
        validator = EmailValidator()
        if validator.validate({"email": "test@test.com"}):
            print("Valido")
    """</code></pre>
                </section>

                <section id="ejercicio">
                    <h2>Ejercicio Guiado</h2>

                    <h3>Sistema de Figuras Geometricas con Herencia</h3>
                    <p>Vamos a crear un sistema de figuras geometricas que demuestra herencia, polimorfismo y clases abstractas.</p>

                    <pre><code class="language-python">"""
Ejercicio Guiado: Sistema de Figuras Geometricas
Demonstra herencia, polimorfismo y clases abstractas.
"""

from abc import ABC, abstractmethod
from math import pi


# ============================================
# CLASE ABSTRACTA BASE
# ============================================

class Figura(ABC):
    """Clase abstracta base para todas las figuras geometricas.

    Attributes:
        color: Color de la figura.
    """

    def __init__(self, color: str = "sin color"):
        self.color = color

    def __str__(self) -> str:
        return f"{self.__class__.__name__} ({self.color})"

    @abstractmethod
    def area(self) -> float:
        """Calcula el area de la figura. Debe ser implementada por subclases."""
        pass

    @abstractmethod
    def perimetro(self) -> float:
        """Calcula el perimetro. Debe ser implementada por subclases."""
        pass

    @abstractmethod
    def describir(self) -> str:
        """Describe la figura."""
        pass


# ============================================
# FIGURAS 2D
# ============================================

class Circulo(Figura):
    """Circulo con radio."""

    def __init__(self, radio: float, color: str = "rojo"):
        super().__init__(color)
        self.radio = radio

    def area(self) -> float:
        """Override: area del circulo = pi * r^2"""
        return pi * self.radio ** 2

    def perimetro(self) -> float:
        """Override: perimetro = 2 * pi * r"""
        return 2 * pi * self.radio

    def describir(self) -> str:
        return f"Circulo de radio {self.radio}"


class Rectangulo(Figura):
    """Rectangulo con ancho y alto."""

    def __init__(self, ancho: float, alto: float, color: str = "azul"):
        super().__init__(color)
        self.ancho = ancho
        self.alto = alto

    def area(self) -> float:
        """Override: area = ancho * alto"""
        return self.ancho * self.alto

    def perimetro(self) -> float:
        """Override: perimetro = 2 * (ancho + alto)"""
        return 2 * (self.ancho + self.alto)

    def describir(self) -> str:
        return f"Rectangulo de {self.ancho}x{self.alto}"


class Cuadrado(Rectangulo):
    """Cuadrado es un rectangulo con lados iguales."""

    def __init__(self, lado: float, color: str = "verde"):
        # super().__init__(lado, lado, color)  # Equivalente
        super().__init__(ancho=lado, alto=lado, color=color)
        self.lado = lado

    def describir(self) -> str:
        return f"Cuadrado de lado {self.lado}"


class Triangulo(Figura):
    """Triangulo con base y altura."""

    def __init__(self, base: float, altura: float, color: str = "amarillo"):
        super().__init__(color)
        self.base = base
        self.altura = altura

    def area(self) -> float:
        """Override: area = (base * altura) / 2"""
        return (self.base * self.altura) / 2

    def perimetro(self) -> float:
        """Perimetro con lados iguales (isosceles)."""
        return 2 * self.altura + self.base  # Simplificado

    def describir(self) -> str:
        return f"Triangulo base {self.base}, altura {self.altura}"


# ============================================
# FIGURAS 3D (HERENCIA DE LA MISMA JERARQUIA)
# ============================================

class Figura3D(Figura):
    """Clase base para figuras 3D."""

    @abstractmethod
    def volumen(self) -> float:
        """Calcula el volumen. Debe ser implementada."""
        pass


class Esfera(Figura3D):
    """Esfera (circulo en 3D)."""

    def __init__(self, radio: float, color: str = "cian"):
        super().__init__(color)
        self.radio = radio

    def area(self) -> float:
        """Area superficial = 4 * pi * r^2"""
        return 4 * pi * self.radio ** 2

    def perimetro(self) -> float:
        """Perimetro en 3D = circunferencia maxima"""
        return 2 * pi * self.radio

    def volumen(self) -> float:
        """Volumen = (4/3) * pi * r^3"""
        return (4/3) * pi * self.radio ** 3

    def describir(self) -> str:
        return f"Esfera de radio {self.radio}"


class Cubo(Figura3D):
    """Cubo (cuadrado en 3D)."""

    def __init__(self, lado: float, color: str = "magenta"):
        super().__init__(color)
        self.lado = lado

    def area(self) -> float:
        """Area superficial = 6 * lado^2"""
        return 6 * self.lado ** 2

    def perimetro(self) -> float:
        """Perimetro total de todas las aristas = 12 * lado"""
        return 12 * self.lado

    def volumen(self) -> float:
        """Volumen = lado^3"""
        return self.lado ** 3

    def describir(self) -> str:
        return f"Cubo de lado {self.lado}"


# ============================================
# FUNCION POLIMORFICA
# ============================================

def mostrar_info(figura: Figura) -> None:
    """Funcion polimorfica que acepta cualquier Figura."""
    print(f"\n{'='*50}")
    print(f"Figura: {figura}")
    print(f"Descripcion: {figura.describir()}")
    print(f"Color: {figura.color}")
    print(f"Area: {figura.area():.4f}")
    print(f"Perimetro: {figura.perimetro():.4f}")

    # Verificar si es 3D
    if isinstance(figura, Figura3D):
        print(f"Volumen: {figura.volumen():.4f}")


# ============================================
# EJECUCION
# ============================================

if __name__ == "__main__":
    print("=== Sistema de Figuras Geometricas ===")
    print("Demonstra herencia, polimorfismo y clases abstractas\n")

    # Lista polimorfica de figuras 2D
    figuras_2d: list[Figura] = [
        Circulo(radio=5, color="rojo"),
        Rectangulo(ancho=4, alto=6, color="azul"),
        Cuadrado(lado=3, color="verde"),
        Triangulo(base=5, altura=4, color="amarillo")
    ]

    # Lista polimorfica de figuras 3D
    figuras_3d: list[Figura3D] = [
        Esfera(radio=3, color="cian"),
        Cubo(lado=2, color="magenta")
    ]

    # Polimorfismo: misma funcion para diferentes tipos
    print("\n--- Figuras 2D ---")
    for fig in figuras_2d:
        mostrar_info(fig)

    print("\n--- Figuras 3D ---")
    for fig in figuras_3d:
        mostrar_info(fig)

    # Resumen
    print("\n" + "="*50)
    print("RESUMEN")
    print("="*50)
    print(f"Total figuras 2D: {len(figuras_2d)}")
    print(f"Total figuras 3D: {len(figuras_3d)}")
    print(f"Total general: {len(figuras_2d) + len(figuras_3d)}")

    # MRO de una clase
    print("\n--- Method Resolution Order (MRO) ---")
    print(f"Cubo: {Cubo.__mro__}")</code></pre>

                    <h4>Ejecuta el Codigo</h4>
                    <pre><code class="language-bash">python figuras.py</code></pre>

                    <h4>Mejoras Propuestas</h4>
                    <ul>
                        <li>Agregar triangulo equilatero con calculo de lados</li>
                        <li>Agregar clase Cilindro que herede de Figura3D</li>
                        <li>Implementar comparacion de areas (>)</li>
                        <li>Agregar validacion de valores positivos</li>
                    </ul>

                    <div class="alert-tip">
                        <strong>Consejo:</strong> Observa como el metodo <code>mostrar_info()</code> funciona para CUALQUIER subclase de Figura. Esto es polimorfismo en su maxima expresion.
                    </div>
                </section>

                <section id="referencias">
                    <h2>Para Profundizar</h2>
                    <ul>
                        <li><a href="https://docs.python.org/es/3/tutorial/classes.html#inheritance" target="_blank">Herencia - Tutorial Oficial de Python</a></li>
                        <li><a href="https://docs.python.org/es/3/library/abc.html" target="_blank">ABC (Abstract Base Classes) - Documentacion Oficial</a></li>
                        <li><a href="https://realpython.com/inheritance-composition-python/" target="_blank">Real Python - Inheritance vs Composition</a></li>
                        <li><a href="https://docs.python.org/es/3/library/stdtypes.html#class.__mro__" target="_blank">MRO - Documentacion Oficial</a></li>
                        <li><a href="https://peps.python.org/pep-0008/" target="_blank">PEP 8 - Guia de Estilo Python</a></li>
                        <li><a href="https://realpython.com/python-super/" target="_blank">Real Python - Python's super()</a></li>
                    </ul>
                </section>

                <section id="taskflow">
                    <h2>Conexion con TaskFlow</h2>
                    <p>La herencia y el polimorfismo son fundamentales para el proyecto TaskFlow:</p>

                    <h3>User y sus Subclases</h3>
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Clase</th>
                                <th>Herencia</th>
                                <th>Proposito</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>User</code></td>
                                <td>Clase base</td>
                                <td>Propiedades comunes: username, email, estado</td>
                            </tr>
                            <tr>
                                <td><code>RegularUser</code></td>
                                <td>Hereda de User</td>
                                <td>Permisos basicos: ver/crear/completar tareas</td>
                            </tr>
                            <tr>
                                <td><code>AdminUser</code></td>
                                <td>Hereda de User</td>
                                <td>Permisos totales: bloquear usuarios, ver estadisticas</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Task y sus Subclases (Proxima Clase)</h3>
                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Clase</th>
                                <th>Herencia</th>
                                <th>Proposito</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>Task</code></td>
                                <td>Clase base</td>
                                <td>Tarea basica: titulo, descripcion, estado</td>
                            </tr>
                            <tr>
                                <td><code>SubTask</code></td>
                                <td>Hereda de Task</td>
                                <td>Subtarea con referencia a tarea padre</td>
                            </tr>
                            <tr>
                                <td><code>RecurringTask</code></td>
                                <td>Hereda de Task</td>
                                <td>Tarea recurrente con frecuencia y fecha fin</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="alert-note">
                        <strong>Estructura del Proyecto:</strong>
                        <pre>taskflow/
├── models/
│   ├── user.py       # User, RegularUser, AdminUser
│   ├── task.py      # Task, SubTask, RecurringTask
│   └── ...
├── services/
│   └── user_service.py  # Polimorfismo en operaciones</pre>
                    </div>

                    <h3>Polimorfismo en TaskFlow</h3>
                    <pre><code class="language-python"># Ejemplo: Funcion que opera con cualquier tipo de usuario
def mostrar_dashboard(usuario: User) -> None:
    """Muestra el dashboard segun el tipo de usuario."""
    print(f"\nDashboard de {usuario.username} ({type(usuario).__name__})")

    # Mismo metodo, diferente comportamiento
    if usuario.tiene_permiso("ver_estadisticas"):
        if isinstance(usuario, AdminUser):
            stats = usuario.ver_estadisticas_sistema()
            print(f"  Usuarios bloqueados: {stats['usuarios_bloqueados']}")
        elif isinstance(usuario, RegularUser):
            stats = usuario.estadisticas()
            print(f"  Tareas completadas: {stats['completadas']}/{stats['total']}")

# Polimorfismo en accion
mostrar_dashboard(admin)       # Dashboard de admin
mostrar_dashboard(regular1)    # Dashboard de usuario regular</code></pre>

                    <div class="alert-warning-custom">
                        <strong>Nota:</strong> En la proxima clase aprenderas sobre encapsulamiento, donde mejoraremos el acceso a los atributos usando propiedades (@property) y protected members (_atributo).
                    </div>
                </section>
            </main>
        </div>
    </div>

    <footer>
        <div class="container">
            <p>&copy; 2026 IF0100 - UNAULA | Todos los derechos reservados</p>
            <p>Ultima actualizacion: 2026-02-08</p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
            crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            Prism.highlightAll();
        });
    </script>
</body>
</html>
