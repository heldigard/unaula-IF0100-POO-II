<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clase 14 - Persistencia con Archivos Planos | IF0100 POO II</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        header {
            background: linear-gradient(135deg, #1e40af, #3b82f6);
            color: white;
            padding: 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        header h1 {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        header .subtitle {
            opacity: 0.9;
            font-size: 0.95rem;
        }

        header .meta {
            margin-top: 1rem;
            padding: 0.75rem;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            font-size: 0.85rem;
        }

        nav {
            background: #1e3a8a;
            padding: 0.75rem 1rem;
            position: sticky;
            top: 120px;
            z-index: 99;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 0;
            padding: 0;
            flex-wrap: wrap;
        }

        nav li {
            margin: 0;
        }

        nav a {
            color: white;
            text-decoration: none;
            font-size: 0.9rem;
            opacity: 0.9;
            transition: opacity 0.2s;
        }

        nav a:hover {
            opacity: 1;
            text-decoration: underline;
        }

        main {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        section {
            background: white;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        section h2 {
            color: #1e40af;
            font-size: 1.4rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #e5e7eb;
        }

        section h3 {
            color: #3b82f6;
            font-size: 1.15rem;
            margin: 1.25rem 0 0.75rem;
        }

        section h4 {
            color: #6b7280;
            font-size: 1rem;
            margin: 1rem 0 0.5rem;
        }

        p {
            margin: 0.75rem 0;
        }

        ul, ol {
            margin: 0.5rem 0 0.75rem 1.5rem;
        }

        li {
            margin: 0.4rem 0;
        }

        .info-box {
            background: #eff6ff;
            border-left: 4px solid #3b82f6;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 6px 6px 0;
        }

        .warning-box {
            background: #fef3c7;
            border-left: 4px solid #f59e0b;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 6px 6px 0;
        }

        .success-box {
            background: #f0fdf4;
            border-left: 4px solid #10b981;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 6px 6px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 0.9rem;
        }

        th {
            background: #1e40af;
            color: white;
            padding: 0.6rem;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 0.6rem;
            border: 1px solid #e5e7eb;
        }

        tr:nth-child(even) {
            background: #f9fafb;
        }

        tr:hover {
            background: #f3f4f6;
        }

        pre {
            background: #1e1e2e;
            color: #cdd6f4;
            padding: 1rem 1.1rem;
            border-radius: 12px;
            overflow-x: auto;
            margin: 1rem 0;
            font-size: 0.85rem;
            line-height: 1.5;
            border: 1px solid #313244;
            box-shadow: 0 4px 20px rgba(0,0,0,0.12);
        }

        code {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #f3f4f6;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.85rem;
        }

        pre code {
            background: transparent;
            padding: 0;
        }

        .keyword { color: #c084fc; }
        .type { color: #38bdf8; }
        .string { color: #4ade80; }
        .comment { color: #94a3b8; font-style: italic; }
        .method { color: #fbbf24; }

        .note {
            background: #f0f4ff;
            border-left: 4px solid #3b82f6;
            padding: 10px 12px;
            border-radius: 8px;
            color: #52606d;
        }
        /* Syntax highlighting para Python */
        .token-keyword { color: #c792ea; font-weight: 600; }
        .token-type { color: #ffcb6b; }
        .token-string { color: #c3e88d; }
        .token-comment { color: #546e7a; font-style: italic; }
        .token-number { color: #f78c6c; }
        .token-operator { color: #89ddff; }
        /* Accessibility */
        abbr[title] { text-decoration: underline dotted; cursor: help; }
        /* Print styles */
        @media print {
            header, nav, footer { background: white !important; color: black !important; }
            a[href]:after { content: " (" attr(href) ")"; font-size: 0.8em; }
            pre, code { white-space: pre-wrap; }
        }

        /* BLOQUES DE CÓDIGO MEJORADOS */
        .code-block {
            background: #1e1e2e;
            border-radius: 12px;
            margin: 16px 0;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: 1px solid #313244;
        }

        .code-header {
            background: linear-gradient(90deg, #313244 0%, #45475a 100%);
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid #45475a;
        }

        .code-dots {
            display: flex;
            gap: 6px;
        }

        .code-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .code-dot.red { background: #f38ba8; }
        .code-dot.yellow { background: #f9e2af; }
        .code-dot.green { background: #a6e3a1; }

        .code-title {
            color: #cdd6f4;
            font-size: 0.85rem;
            font-weight: 600;
            margin-left: auto;
            font-family: 'Cascadia Code', Consolas, monospace;
        }

        .code-content {
            display: flex;
            background: #1e1e2e;
        }

        .line-numbers {
            background: #181825;
            color: #6c7086;
            padding: 12px 10px;
            text-align: right;
            font-family: 'Cascadia Code', Consolas, monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            user-select: none;
            border-right: 1px solid #313244;
        }

        .code-block pre {
            background: transparent;
            margin: 0;
            padding: 12px 16px;
            flex: 1;
            overflow-x: auto;
        }

        .code-block pre code {
            color: #cdd6f4;
            font-size: 0.95rem;
            line-height: 1.5;
            display: block;
        }

        /* Syntax highlighting mejorado - Catppuccin Mocha theme */
        .code-block .token-keyword { color: #cba6f7; font-weight: 600; } /* purple */
        .code-block .token-type { color: #f9e2af; } /* yellow */
        .code-block .token-string { color: #a6e3a1; } /* green */
        .code-block .token-comment { color: #6c7086; font-style: italic; } /* gray */
        .code-block .token-number { color: #fab387; } /* peach */
        .code-block .token-operator { color: #89dceb; } /* cyan */
        .code-block .token-method { color: #89b4fa; } /* blue */
        .code-block .token-class { color: #f9e2af; font-weight: 600; }
        .code-block .token-property { color: #b4befe; } /* lavender */
        .code-block .token-namespace { color: #f38ba8; } /* pink */

        /* Código inline */
        p code, li code {
            background: #313244;
            color: #cdd6f4;
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 0.9em;
            border: 1px solid #45475a;
        }

        /* Tablas de código */
        .code-comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
            margin: 16px 0;
        }

        .code-comparison .code-block {
            margin: 0;
        }

        .code-label {
            font-size: 0.8rem;
            color: #6c7086;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .diagram {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 6px;
            text-align: center;
            font-family: monospace;
            font-size: 0.9rem;
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .badge-primary { background: #dbeafe; color: #1e40af; }
        .badge-success { background: #d1fae5; color: #065f46; }
        .badge-warning { background: #fef3c7; color: #92400e; }
        .badge-danger { background: #fee2e2; color: #991b1b; }

        footer {
            text-align: center;
            padding: 2rem;
            color: #6b7280;
            font-size: 0.85rem;
        }

        @media (max-width: 768px) {
            header h1 { font-size: 1.4rem; }
            nav { position: static; }
            nav a { display: inline-block; margin: 0.5rem 0.75rem; }
            section { padding: 1rem; }
        }
        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: #1e40af;
            color: #fff;
            padding: 8px 16px;
            text-decoration: none;
            z-index: 100;
            transition: top 0.3s;
        }
        .skip-link:focus {
            top: 0;
        }
    </style>
</head>
<body>
    <a href="#main" class="skip-link">Saltar al contenido</a>
    <header>
        <h1>Clase 14: Persistencia con Archivos Planos</h1>
        <p class="subtitle">IF0100 - Lenguaje de Programación Orientada a Objetos II | Unidad 4: Persistencia de Datos</p>
        <div class="meta">
            <strong>Duración:</strong> 90 minutos |
            <strong>Fecha:</strong> 2026-I Semestre |
            <strong>UNAULA</strong> - Ingeniería Informática
        </div>
    </header>

    <nav>
        <ul>
            <li><a href="#teoria">Teoría</a></li>
            <li><a href="#ejemplos">Ejemplos</a></li>
            <li><a href="#practica">Práctica / Laboratorio</a></li>
            <li><a href="#ejercicios">Ejercicios</a></li>
            <li><a href="#referencias">Referencias</a></li>
        </ul>
    </nav>

    <main id="main">
        <!-- Teoría -->
        <section id="teoria">
        <!-- Objetivos -->
        <section id="objetivos">
            <h2>Objetivos de Aprendizaje</h2>
            <p>Al finalizar esta clase, el estudiante será capaz de:</p>
            <ul>
                <li><strong>Leer y escribir</strong> archivos de texto en Python con <code>pathlib</code> y <code>open()</code></li>
                <li><strong>Manipular</strong> archivos CSV con el módulo <code>csv</code></li>
                <li><strong>Serializar</strong> objetos a JSON con el módulo <code>json</code></li>
                <li><strong>Comparar</strong> archivos planos vs bases de datos para elegir la mejor opción</li>
                <li><strong>Implementar</strong> patrones Repository para persistencia simple</li>
                <li><strong>Manejar</strong> configuración INI y compresión con <code>configparser</code>, <code>gzip</code> y <code>zipfile</code></li>
            </ul>

            <h3 style="margin-top: 1.5rem;">Prerrequisitos</h3>
            <ul>
                <li>Conocimiento básico de Python y POO</li>
                <li>Manejo de listas/diccionarios</li>
                <li>Conceptos básicos de persistencia de datos</li>
            </ul>
        </section>

        <!-- Teoría -->
        <section id="teoria">
            <h2>1. Fundamentos de Archivos Planos</h2>

            <p><strong><abbr title="Archivos planos - Archivos de texto sin estructura compleja (CSV, JSON, XML, INI, TXT)">Archivos planos</abbr></strong> = Archivos de texto que almacenan datos sin un motor de base de datos. Son legibles por humanos y editables con cualquier editor de texto.</p>

            <h3>¿Cuándo usar archivos planos?</h3>

            <div class="success-box">
                <p><strong>Casos de uso adecuados:</strong></p>
                <ul>
                    <li>Configuraciones de aplicación</li>
                    <li>Logs y auditorías</li>
                    <li>Exportación de datos (CSV, JSON)</li>
                    <li>Caché simple</li>
                    <li>Aplicaciones sin acceso a DBMS</li>
                </ul>
            </div>

            <div class="warning-box">
                <p><strong>Evitar para:</strong></p>
                <ul>
                    <li>Grandes volúmenes de datos</li>
                    <li>Múltiples usuarios concurrentes</li>
                    <li>Necesidad de consultas complejas</li>
                    <li>Alta frecuencia de escritura</li>
                </ul>
            </div>

            <h3>Comparación: Archivo Plano vs Base de Datos</h3>
            <table>
                <thead>
                    <tr>
                        <th>Caso</th>
                        <th>Archivo Plano</th>
                        <th>Base de Datos</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Pocos datos</td>
                        <td><span class="badge badge-success">✅ Recomendado</span></td>
                        <td><span class="badge badge-danger">❌ Sobredimensionado</span></td>
                    </tr>
                    <tr>
                        <td>Multiusuario</td>
                        <td><span class="badge badge-danger">❌ No adecuado</span></td>
                        <td><span class="badge badge-success">✅ Recomendado</span></td>
                    </tr>
                    <tr>
                        <td>Consultas complejas</td>
                        <td><span class="badge badge-danger">❌ Limitado</span></td>
                        <td><span class="badge badge-success">✅ Recomendado</span></td>
                    </tr>
                    <tr>
                        <td>Portabilidad</td>
                        <td><span class="badge badge-success">✅ Recomendado</span></td>
                        <td><span class="badge badge-warning">⚠️ Complejo</span></td>
                    </tr>
                </tbody>
            </table>
        </section>
        </section>

        <!-- Ejemplos -->
        <section id="ejemplos">
            <h2>2. Python I/O - pathlib y open()</h2>

            <p><strong>pathlib</strong> = Módulo de Python para trabajar con rutas y archivos de forma orientada a objetos.</p>
            <p><strong><abbr title="List comprehensions - Sintaxis compacta de Python para filtrar y transformar listas">List comprehensions</abbr></strong> = Forma idiomática de filtrar/transformar colecciones.</p>
            <p><strong><abbr title="Typing - Anotaciones de tipo opcionales para documentar y validar">Typing</abbr></strong> = Tipos opcionales para claridad y herramientas estáticas.</p>
            <p><strong><abbr title="Serialización - Proceso de convertir objetos a formato portable (JSON, XML, binario)">Serialización</abbr></strong> = Convertir un objeto en memoria a un formato que pueda guardarse en archivo o transmitirse por red.</p>

            <h3>Clases Principales</h3>
            <table>
                <thead>
                    <tr>
                        <th>Clase</th>
                        <th>Propósito</th>
                        <th>Uso Típico</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>pathlib.Path</code></td>
                        <td>Rutas y operaciones de archivos</td>
                        <td>Crear, leer, escribir, listar</td>
                    </tr>
                    <tr>
                        <td><code>open()</code></td>
                        <td>Lectura/escritura de texto</td>
                        <td>Lectura línea por línea, append</td>
                    </tr>
                    <tr>
                        <td><code>csv</code></td>
                        <td>Lectura/escritura de CSV</td>
                        <td>DictReader/DictWriter</td>
                    </tr>
                    <tr>
                        <td><code>json</code></td>
                        <td>Serialización JSON</td>
                        <td>dump/load para APIs y config</td>
                    </tr>
                    <tr>
                        <td><code>gzip/zipfile</code></td>
                        <td>Compresión</td>
                        <td>Backups y distribución</td>
                    </tr>
                </tbody>
            </table>

            <div class="warning-box">
                <strong>Errores Comunes con Archivos</strong>
                <ul>
                    <li><strong>Olvidar el context manager:</strong> El archivo queda abierto y puede bloquearse</li>
                    <li><strong>Encoding incorrecto:</strong> Caracteres especiales se corrompen</li>
                    <li><strong>Path sin validar:</strong> Verificar existencia antes de leer</li>
                    <li><strong>Permisos insuficientes:</strong> Error al escribir en rutas protegidas</li>
                </ul>
            </div>

            <h3>Conceptos Clave</h3>
            <p><strong><abbr title="Modo binario - Abrir con 'rb'/'wb' para leer o escribir bytes">Modo binario</abbr></strong> = Permite lectura/escritura de bytes para imágenes o archivos comprimidos.</p>
            <p><strong><abbr title="Encoding - Forma en que se representan los caracteres como bytes (UTF-8, ASCII, UTF-16)">Encoding</abbr></strong> = Mapa de caracteres a bytes. UTF-8 es el estándar web y soporta todos los caracteres del mundo.</p>
            <p><strong><abbr title="Buffering - Técnica de acumular datos en memoria para reducir operaciones de I/O">Buffering</abbr></strong> = Python usa buffer interno para reducir llamadas al disco (lee/escribe bloques).</p>

            <h3>Operaciones Básicas</h3>
            <pre><code><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path

<span class="comment"># Escribir texto completo</span>
Path(<span class="string">"datos.txt"</span>).write_text(<span class="string">"Hola UNAULA"</span>, encoding=<span class="string">"utf-8"</span>)

<span class="comment"># Leer texto completo</span>
contenido = Path(<span class="string">"datos.txt"</span>).read_text(encoding=<span class="string">"utf-8"</span>)

<span class="comment"># Agregar texto al final</span>
<span class="keyword">with</span> <span class="method">open</span>(<span class="string">"log.txt"</span>, <span class="string">"a"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
    f.write(<span class="string">"Nueva entrada\n"</span>)

<span class="comment"># Verificar si existe</span>
<span class="keyword">if</span> Path(<span class="string">"datos.txt"</span>).exists():
    <span class="comment"># El archivo existe</span>
    <span class="keyword">pass</span>

<span class="comment"># Leer todas las líneas</span>
lineas = Path(<span class="string">"archivo.txt"</span>).read_text(encoding=<span class="string">"utf-8"</span>).splitlines()</code></pre>

            <h3>Lectura y escritura con context manager</h3>
            <pre><code><span class="comment"># Escribir (mejor para archivos grandes)</span>
<span class="keyword">with</span> <span class="method">open</span>(<span class="string">"salida.txt"</span>, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
    f.write(<span class="string">"Línea 1\n"</span>)
    f.write(<span class="string">"Línea 2\n"</span>)

<span class="comment"># Leer línea por línea</span>
<span class="keyword">with</span> <span class="method">open</span>(<span class="string">"entrada.txt"</span>, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
    <span class="keyword">for</span> linea <span class="keyword">in</span> f:
        <span class="method">print</span>(linea.strip())</code></pre>
        </section>

        <!-- CSV -->
        <section id="csv">
            <h2>3. Persistencia con CSV</h2>

            <h3>Formato CSV</h3>
            <p><strong><abbr title="CSV - Comma-Separated Values, formato de texto para datos tabulares donde los campos se separan por comas">CSV</abbr></strong> = Formato de texto plano para datos tabulares donde cada línea es un registro y los campos se separan por comas (u otro delimitador).</p>
            <p>Es el formato más simple para intercambiar datos con Excel y otras herramientas de hojas de cálculo.</p>
            <div class="info-box">
                <p><strong>CSV</strong>: El estándar de facto para importación/exportación de datos tabulares.</p>
            </div>

            <h4>Ejemplo de Archivo CSV</h4>
            <pre><code>Id,Nombre,Precio,Categoria
1,Teclado,120000,Periféricos
2,Mouse,80000,Periféricos
3,Monitor,450000,Pantallas</code></pre>

            <h3>Lectura Básica de CSV</h3>
            <pre><code><span class="keyword">import</span> csv

<span class="keyword">with</span> <span class="method">open</span>(<span class="string">"productos.csv"</span>, newline=<span class="string">""</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
    reader = csv.DictReader(f)
    <span class="keyword">for</span> row <span class="keyword">in</span> reader:
        <span class="method">print</span>(<span class="string">f"{row['Id']} - {row['Nombre']}: ${row['Precio']}"</span>)</code></pre>

            <h3>Repository CSV - Estructura Base</h3>
            <pre><code><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass
<span class="keyword">import</span> csv
<span class="keyword">from</span> pathlib <span class="keyword">import</span> Path

<span class="keyword">@dataclass</span>
<span class="keyword">class</span> <span class="type">Estudiante</span>:
    id: int
    codigo: str
    nombre: str
    apellido: str
    email: str
    promedio: float
    activo: bool = <span class="keyword">True</span>

<span class="keyword">class</span> <span class="type">EstudianteRepositoryCSV</span>:
    <span class="keyword">def</span> __init__(<span class="keyword">self</span>, file_path=<span class="string">"estudiantes.csv"</span>):
        <span class="keyword">self</span>.file_path = Path(file_path)
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.file_path.exists():
            <span class="keyword">with</span> <span class="method">open</span>(<span class="keyword">self</span>.file_path, <span class="string">"w"</span>, newline=<span class="string">""</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
                writer = csv.DictWriter(f, fieldnames=[<span class="string">"Id"</span>, <span class="string">"Codigo"</span>, <span class="string">"Nombre"</span>, <span class="string">"Apellido"</span>, <span class="string">"Email"</span>, <span class="string">"Promedio"</span>, <span class="string">"Activo"</span>])
                writer.writeheader()

    <span class="keyword">def</span> obtener_todos(<span class="keyword">self</span>) -> list[Estudiante]:
        <span class="keyword">with</span> <span class="method">open</span>(<span class="keyword">self</span>.file_path, newline=<span class="string">""</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
            reader = csv.DictReader(f)
            <span class="keyword">return</span> [
                Estudiante(
                    id=<span class="type">int</span>(row[<span class="string">"Id"</span>]),
                    codigo=row[<span class="string">"Codigo"</span>],
                    nombre=row[<span class="string">"Nombre"</span>],
                    apellido=row[<span class="string">"Apellido"</span>],
                    email=row[<span class="string">"Email"</span>],
                    promedio=<span class="type">float</span>(row[<span class="string">"Promedio"</span>]),
                    activo=row[<span class="string">"Activo"</span>] == <span class="string">"1"</span>,
                )
                <span class="keyword">for</span> row <span class="keyword">in</span> reader
            ]

    <span class="keyword">def</span> crear(<span class="keyword">self</span>, estudiante: Estudiante) -> None:
        <span class="keyword">with</span> <span class="method">open</span>(<span class="keyword">self</span>.file_path, <span class="string">"a"</span>, newline=<span class="string">""</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
            writer = csv.DictWriter(f, fieldnames=[<span class="string">"Id"</span>, <span class="string">"Codigo"</span>, <span class="string">"Nombre"</span>, <span class="string">"Apellido"</span>, <span class="string">"Email"</span>, <span class="string">"Promedio"</span>, <span class="string">"Activo"</span>])
            writer.writerow({
                <span class="string">"Id"</span>: estudiante.id,
                <span class="string">"Codigo"</span>: estudiante.codigo,
                <span class="string">"Nombre"</span>: estudiante.nombre,
                <span class="string">"Apellido"</span>: estudiante.apellido,
                <span class="string">"Email"</span>: estudiante.email,
                <span class="string">"Promedio"</span>: estudiante.promedio,
                <span class="string">"Activo"</span>: <span class="string">"1"</span> <span class="keyword">if</span> estudiante.activo <span class="keyword">else</span> <span class="string">"0"</span>,
            })</code></pre>

            <h3>Manejo de Comillas en CSV</h3>
            <p>El módulo <code>csv</code> maneja comillas automáticamente cuando hay comas dentro de campos.</p>
            <pre><code>writer = csv.DictWriter(
    f,
    fieldnames=[...],
    quoting=csv.QUOTE_MINIMAL
)</code></pre>
        </section>

        <!-- JSON -->
        <section id="json">
            <h2>4. Persistencia con JSON</h2>

            <h3>Módulo json</h3>
            <p><strong><abbr title="JSON - JavaScript Object Notation, formato ligero de intercambio de datos basado en texto">JSON</abbr></strong> = Formato ligero de intercambio de datos, legible para humanos y nativo de JavaScript. Es el estándar de facto para APIs web.</p>
            <div class="info-box">
                <p><strong>Ventajas de JSON sobre XML:</strong> Más ligero, más fácil de parsear, soporte nativo en JavaScript.</p>
            </div>

            <h3>Serialización Básica</h3>
            <pre><code><span class="keyword">import</span> json

<span class="comment"># Serializar objeto a JSON</span>
producto = {<span class="string">"id"</span>: 1, <span class="string">"nombre"</span>: <span class="string">"Teclado"</span>, <span class="string">"precio"</span>: 120000}
json_str = json.dumps(producto)

<span class="comment"># Serializar con formato legible</span>
json_bonito = json.dumps(producto, indent=2, ensure_ascii=<span class="keyword">False</span>)

<span class="comment"># Deserializar</span>
producto2 = json.loads(json_str)

<span class="comment"># Serializar lista</span>
productos = [producto, producto2]
json_array = json.dumps(productos, indent=2, ensure_ascii=<span class="keyword">False</span>)</code></pre>

            <h3>Repository JSON - Estructura Base</h3>
            <pre><code><span class="keyword">using</span> System;
<span class="keyword">using</span> System.Collections.Generic;
<span class="keyword">using</span> System.IO;
<span class="keyword">using</span> System.Linq;
<span class="keyword">using</span> System.Text.Json;

<span class="keyword">public class</span> <span class="type">EstudianteRepositoryJSON</span>
{
    <span class="keyword">private readonly</span> <span class="type">string</span> _filePath;
    <span class="keyword">private readonly</span> <span class="type">JsonSerializerOptions</span> _jsonOptions;

    <span class="keyword">public</span> <span class="method">EstudianteRepositoryJSON</span>(<span class="type">string</span> filePath = <span class="string">"estudiantes.json"</span>)
    {
        _filePath = filePath;
        _jsonOptions = <span class="keyword">new</span> <span class="type">JsonSerializerOptions</span>
        {
            WriteIndented = <span class="keyword">true</span>,
            PropertyNamingPolicy = <span class="type">JsonNamingPolicy</span>.CamelCase
        };

        <span class="comment">// Crear archivo vacío si no existe</span>
        <span class="keyword">if</span> (!File.Exists(_filePath))
        {
            File.WriteAllText(_filePath, <span class="string">"[]"</span>);
        }
    }

    <span class="keyword">public void</span> <span class="method">Crear</span>(<span class="type">Estudiante</span> estudiante)
    {
        <span class="type">var</span> estudiantes = ObtenerTodos();

        <span class="comment">// Generar ID automático</span>
        estudiante.Id = estudiantes.Any()
            ? estudiantes.Max(e => e.Id) + 1
            : 1;

        estudiantes.Add(estudiante);
        GuardarTodos(estudiantes);
    }

    <span class="keyword">public</span> <span class="type">List</span>&lt;<span class="type">Estudiante</span>&gt; <span class="method">ObtenerTodos</span>()
    {
        <span class="keyword">try</span>
        {
            <span class="type">string</span> json = File.ReadAllText(_filePath);
            <span class="type">var</span> estudiantes = JsonSerializer.Deserialize&lt;<span class="type">List</span>&lt;<span class="type">Estudiante</span>&gt;&gt;(json, _jsonOptions);
            <span class="keyword">return</span> estudiantes?.Where(e => e.Activo).ToList()
                ?? <span class="keyword">new</span> <span class="type">List</span>&lt;<span class="type">Estudiante</span>&gt;();
        }
        <span class="keyword">catch</span> (<span class="type">JsonException</span> ex)
        {
            <span class="type">Console</span>.WriteLine(<span class="string">$"Error al leer JSON: {ex.Message}"</span>);
            <span class="keyword">return new</span> <span class="type">List</span>&lt;<span class="type">Estudiante</span>&gt;();
        }
    }

    <span class="keyword">public bool</span> <span class="method">Actualizar</span>(<span class="type">Estudiante</span> estudiante)
    {
        <span class="type">var</span> estudiantes = LeerTodos();
        <span class="type">var</span> index = estudiantes.FindIndex(e => e.Id == estudiante.Id);

        <span class="keyword">if</span> (index == -1) <span class="keyword">return false</span>;

        estudiantes[index] = estudiante;
        GuardarTodos(estudiantes);
        <span class="keyword">return true</span>;
    }

    <span class="keyword">private</span> <span class="type">List</span>&lt;<span class="type">Estudiante</span>&gt; <span class="method">LeerTodos</span>()
    {
        <span class="type">string</span> json = File.ReadAllText(_filePath);
        <span class="keyword">return</span> JsonSerializer.Deserialize&lt;<span class="type">List</span>&lt;<span class="type">Estudiante</span>&gt;&gt;(json, _jsonOptions)
            ?? <span class="keyword">new</span> <span class="type">List</span>&lt;<span class="type">Estudiante</span>&gt;();
    }

    <span class="keyword">private</span> <span class="type">void</span> <span class="method">GuardarTodos</span>(<span class="type">List</span>&lt;<span class="type">Estudiante</span>&gt; estudiantes)
    {
        <span class="type">string</span> json = JsonSerializer.Serialize(estudiantes, _jsonOptions);
        File.WriteAllText(_filePath, json);
    }
}</code></pre>

            <h3>Ejemplo de Archivo JSON</h3>
            <pre><code>[
  {
    <span class="string">"Id"</span>: 1,
    <span class="string">"Codigo"</span>: <span class="string">"EST001"</span>,
    <span class="string">"Nombre"</span>: <span class="string">"Juan"</span>,
    <span class="string">"Apellido"</span>: <span class="string">"Pérez"</span>,
    <span class="string">"Email"</span>: <span class="string">"juan.perez@unaula.edu.co"</span>,
    <span class="string">"Promedio"</span>: 4.2,
    <span class="string">"Activo"</span>: <span class="keyword">true</span>
  },
  {
    <span class="string">"Id"</span>: 2,
    <span class="string">"Codigo"</span>: <span class="string">"EST002"</span>,
    <span class="string">"Nombre"</span>: <span class="string">"María"</span>,
    <span class="string">"Apellido"</span>: <span class="string">"González"</span>,
    <span class="string">"Email"</span>: <span class="string">"maria.gonzalez@unaula.edu.co"</span>,
    <span class="string">"Promedio"</span>: 4.5,
    <span class="string">"Activo"</span>: <span class="keyword">true</span>
  }
]</code></pre>
        </section>

        <!-- XML -->
        <section id="xml">
            <h2>5. Persistencia con XML</h2>

            <h3>xml.etree.ElementTree</h3>
            <p><strong><abbr title="XML - eXtensible Markup Language, lenguaje de marcado para documentos estructurados">XML</abbr></strong> = Lenguaje de marcado para estructurar datos con etiquetas jerárquicas. Es más pesado que JSON pero soporta schemas y metadatos.</p>
            <p><strong><abbr title="ElementTree - Módulo estándar de Python para leer/escribir XML">ElementTree</abbr></strong> = Módulo que permite crear, leer y escribir XML desde Python.</p>

            <div class="warning-box">
                <strong>¿Cuándo usar XML en lugar de JSON?</strong>
                <ul>
                    <li><strong>Necesitas schemas:</strong> XML tiene XSD para validar estructura</li>
                    <li><strong>Sistemas legacy:</strong> Muchos sistemas empresariales usan SOAP/XML</li>
                    <li><strong>Metadatos:</strong> XML es mejor para documentos complejos con atributos</li>
                </ul>
            </div>
            <pre><code><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET
<span class="keyword">from</span> pathlib <span class="keyword">import</span> Path

<span class="keyword">class</span> <span class="type">EstudianteRepositoryXML</span>:
    <span class="keyword">def</span> __init__(<span class="keyword">self</span>, file_path=<span class="string">"estudiantes.xml"</span>):
        <span class="keyword">self</span>.file_path = Path(file_path)
        <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">self</span>.file_path.exists():
            root = ET.Element(<span class="string">"estudiantes"</span>)
            ET.ElementTree(root).write(<span class="keyword">self</span>.file_path, encoding=<span class="string">"utf-8"</span>, xml_declaration=<span class="keyword">True</span>)

    <span class="keyword">def</span> obtener_todos(<span class="keyword">self</span>) -> list[dict]:
        tree = ET.parse(<span class="keyword">self</span>.file_path)
        root = tree.getroot()
        <span class="keyword">return</span> [e.attrib <span class="keyword">for</span> e <span class="keyword">in</span> root.findall(<span class="string">"estudiante"</span>)]

    <span class="keyword">def</span> crear(<span class="keyword">self</span>, estudiante: dict) -> None:
        tree = ET.parse(<span class="keyword">self</span>.file_path)
        root = tree.getroot()
        ET.SubElement(root, <span class="string">"estudiante"</span>, attrib=estudiante)
        tree.write(<span class="keyword">self</span>.file_path, encoding=<span class="string">"utf-8"</span>, xml_declaration=<span class="keyword">True</span>)</code></pre>
        </section>

        <!-- Comparación -->
        <section>
            <h2>6. Comparación de Formatos</h2>

            <h3>Análisis Comparativo</h3>
            <table>
                <thead>
                    <tr>
                        <th>Aspecto</th>
                        <th>CSV</th>
                        <th>JSON</th>
                        <th>XML</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Legibilidad</strong></td>
                        <td><span class="badge badge-warning">⭐⭐</span> Medio</td>
                        <td><span class="badge badge-success">⭐⭐⭐</span> Alto</td>
                        <td><span class="badge badge-warning">⭐⭐</span> Medio</td>
                    </tr>
                    <tr>
                        <td><strong>Tamaño</strong></td>
                        <td><span class="badge badge-success">⭐⭐⭐</span> Pequeño</td>
                        <td><span class="badge badge-warning">⭐⭐</span> Medio</td>
                        <td><span class="badge badge-danger">⭐</span> Grande</td>
                    </tr>
                    <tr>
                        <td><strong>Facilidad Parsing</strong></td>
                        <td><span class="badge badge-warning">⭐⭐</span> Medio</td>
                        <td><span class="badge badge-success">⭐⭐⭐</span> Fácil</td>
                        <td><span class="badge badge-warning">⭐⭐</span> Medio</td>
                    </tr>
                    <tr>
                        <td><strong>Soporte Tipos</strong></td>
                        <td><span class="badge badge-danger">⭐</span> Todo texto</td>
                        <td><span class="badge badge-success">⭐⭐⭐</span> Completo</td>
                        <td><span class="badge badge-success">⭐⭐⭐</span> Completo</td>
                    </tr>
                    <tr>
                        <td><strong>Interoperabilidad</strong></td>
                        <td><span class="badge badge-success">⭐⭐⭐</span> Universal</td>
                        <td><span class="badge badge-success">⭐⭐⭐</span> Web estándar</td>
                        <td><span class="badge badge-success">⭐⭐⭐</span> Empresarial</td>
                    </tr>
                    <tr>
                        <td><strong>Complejidad</strong></td>
                        <td><span class="badge badge-success">⭐</span> Simple</td>
                        <td><span class="badge badge-warning">⭐⭐</span> Medio</td>
                        <td><span class="badge badge-danger">⭐⭐⭐</span> Complejo</td>
                    </tr>
                </tbody>
            </table>

            <h3>Casos de Uso Recomendados</h3>
            <table>
                <thead>
                    <tr>
                        <th>Formato</th>
                        <th>Ideal para...</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>CSV</strong></td>
                        <td>Exportar datos tabulares, Excel, importación masiva</td>
                    </tr>
                    <tr>
                        <td><strong>JSON</strong></td>
                        <td>APIs web, configuración moderna, intercambio de datos</td>
                    </tr>
                    <tr>
                        <td><strong>XML</strong></td>
                        <td>APIs SOAP, documentos con metadatos, legacy systems</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section id="equivalencia-datos-desconectados">
            <h2>Equivalencia: DataSet/DataAdapter → Python + Angular</h2>
            <p>En ADO.NET, <strong>DataSet</strong> y <strong>DataAdapter</strong> permiten trabajar con datos desconectados y sincronizar cambios. En el stack actual, la equivalencia se logra con DTOs, estado local y sincronización explícita.</p>
            <div class="note">
                <strong>Equivalencias clave</strong>
                <ul>
                    <li><code>DataSet</code> → Estado local en Angular (signals/BehaviorSubject)</li>
                    <li><code>DataTable</code> → Listas de DTOs en memoria</li>
                    <li><code>DataAdapter.Fill()</code> → GET a la API + carga en estado</li>
                    <li><code>DataAdapter.Update()</code> → POST/PUT para sincronizar cambios</li>
                    <li><code>AcceptChanges()</code> → Confirmar cambios locales</li>
                    <li><code>RejectChanges()</code> → Revertir cambios locales</li>
                </ul>
            </div>
        </section>

        <!-- Avanzado -->
        <section id="avanzado">
            <h2>7. Temas Avanzados</h2>

            <h3>Archivos de Configuración INI</h3>
            <p><strong><abbr title="INI - Formato de archivo de configuración con secciones y clave=valor (popular en Windows)">INI</abbr></strong> = Formato simple de archivos de configuración con secciones entre corchetes [Sección] y pares clave=valor.</p>
            <pre><code><span class="comment">// Archivo config.ini:</span>
<span class="comment">; Archivo de configuración de UniversidadApp</span>

[Database]
Server=localhost
Port=1433
Database=UniversidadDB
UseSSL=<span class="keyword">true</span>

[App]
Theme=Dark
Language=es-CO
PageSize=20</code></pre>

            <pre><code><span class="keyword">import</span> configparser

config = configparser.ConfigParser()
config.read(<span class="string">"config.ini"</span>, encoding=<span class="string">"utf-8"</span>)

servidor = config.get(<span class="string">"Database"</span>, <span class="string">"Server"</span>, fallback=<span class="string">"localhost"</span>)
puerto = config.getint(<span class="string">"Database"</span>, <span class="string">"Port"</span>, fallback=1433)
db = config.get(<span class="string">"Database"</span>, <span class="string">"Database"</span>, fallback=<span class="string">"UniversidadDB"</span>)</code></pre>

            <h3>Compresión de Archivos</h3>
            <p><strong><abbr title="GZIP - Formato de compresión GNU ZIP (algoritmo DEFLATE)">GZIP</abbr></strong> = Formato de compresión que reduce el tamaño de archivos individuales. Es estándar en Linux y para archivos web (.gz).</p>
            <p><strong><abbr title="ZIP - Formato de archivo que puede contener múltiples archivos comprimidos">ZIP</abbr></strong> = Contenedor que puede almacenar múltiples archivos comprimidos. Es el formato estándar para distribuciones de software.</p>

            <div class="info-box">
                <strong>¿Por qué comprimir archivos?</strong>
                <ul>
                    <li><strong>Ahorro espacio:</strong> Archivos de texto pueden reducirse hasta 80%</li>
                    <li><strong>Más rápido:</strong> Transferir 1MB comprimido es más rápido que 10MB sin comprimir</li>
                    <li><strong>Backups:</strong> Comprimir logs antiguos para ahorrar disco</li>
                </ul>
            </div>

            <h4>GZIP - Compresión individual</h4>
            <pre><code><span class="keyword">import</span> gzip
<span class="keyword">import</span> shutil
<span class="keyword">import</span> zipfile
<span class="keyword">from</span> pathlib <span class="keyword">import</span> Path

<span class="keyword">def</span> <span class="method">compress_gzip</span>(source_path: str, compressed_path: str) -> None:
    <span class="keyword">with</span> <span class="method">open</span>(source_path, <span class="string">"rb"</span>) <span class="keyword">as</span> f_in, gzip.open(compressed_path, <span class="string">"wb"</span>) <span class="keyword">as</span> f_out:
        shutil.copyfileobj(f_in, f_out)

<span class="comment"># Crear ZIP con múltiples archivos</span>
<span class="keyword">def</span> <span class="method">create_zip</span>(zip_path: str, files_to_include: list[str]) -> None:
    <span class="keyword">with</span> zipfile.ZipFile(zip_path, <span class="string">"w"</span>, compression=zipfile.ZIP_DEFLATED) <span class="keyword">as</span> zf:
        <span class="keyword">for</span> file_path <span class="keyword">in</span> files_to_include:
            path = Path(file_path)
            <span class="keyword">if</span> path.exists():
                zf.write(path, arcname=path.name)</code></pre>

            <h3>Logger de Auditoría</h3>
            <pre><code><span class="keyword">import</span> logging

logging.basicConfig(
    filename=<span class="string">"auditoria.log"</span>,
    level=logging.INFO,
    format=<span class="string">"%(asctime)s - %(message)s"</span>,
)

<span class="keyword">def</span> <span class="method">log_operacion</span>(operacion: str, detalles: str, usuario: str) -> None:
    logging.info(<span class="string">f"{operacion} - {detalles} por {usuario}"</span>)

<span class="comment"># Ejemplo de salida:</span>
<span class="comment"># 2026-02-01 18:30:15,123 - CREATE - Estudiante EST004 creado por Usuario1</span></code></pre>
        </section>

        <!-- Práctica / Laboratorio -->
        <section id="practica">
            <h2>Práctica / Laboratorio</h2>
            <p>Para ejercicios prácticos, consulte la sección de ejercicios a continuación.</p>
        </section>

        <!-- Ejercicios -->
        <section id="ejercicios" class="actividad">
            <h3>Actividad: Ejercicios de Persistencia de Datos</h3>
            <p><strong>Tipo:</strong> Opcional / práctica</p>
            <p><strong>Relacionado con:</strong> Ninguno</p>
            <p><strong>Entregable:</strong> Ejercicios de CSV, JSON, XML y Logger</p>
            <p><strong>Tiempo estimado:</strong> 60 min</p>
            <p><strong>Criterios de éxito:</strong> Comprensión de manejo de archivos en diferentes formatos</p>
            <h2>8. Ejercicios Prácticos</h2>

            <h3>Ejercicio 1: Exportar a CSV</h3>
            <p>Crear un método que exporte una lista de estudiantes a CSV con encoding UTF-8.</p>
            <div class="info-box">
                <strong>Requisitos:</strong>
                <ul>
                    <li>Incluir encabezado con nombres de columnas</li>
                    <li>Usar UTF-8 para soportar caracteres especiales</li>
                    <li>Manejar campos con comas usando comillas</li>
                </ul>
            </div>

            <h3>Ejercicio 2: Importar desde JSON</h3>
            <p>Leer un archivo JSON de productos y cargarlos en una lista.</p>
            <div class="info-box">
                <strong>Requisitos:</strong>
                <ul>
                    <li>Validar que el archivo existe antes de leer</li>
                    <li>Manejar errores de formato JSON</li>
                    <li>Retornar lista vacía si hay error</li>
                </ul>
            </div>

            <h3>Ejercicio 3: Logger con Timestamp</h3>
            <p>Implementar un logger que escriba en archivo de texto con timestamp.</p>
            <pre><code><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime

<span class="keyword">def</span> <span class="method">log</span>(mensaje: str) -> None:
    linea = <span class="string">f"[{datetime.now():%Y-%m-%d %H:%M:%S}] {mensaje}"</span>
    <span class="keyword">with</span> <span class="method">open</span>(<span class="string">"log.txt"</span>, <span class="string">"a"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
        f.write(linea + <span class="string">"\n"</span>)</code></pre>

            <h3>Ejercicio 4: Migración de Formatos</h3>
            <p>Implementar un método que convierta datos entre CSV ↔ JSON ↔ XML.</p>
            <pre><code><span class="keyword">import</span> csv
<span class="keyword">import</span> json

<span class="keyword">def</span> <span class="method">csv_a_json</span>(csv_path: str, json_path: str) -> None:
    <span class="keyword">with</span> <span class="method">open</span>(csv_path, newline=<span class="string">""</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
        reader = csv.DictReader(f)
        datos = [row <span class="keyword">for</span> row <span class="keyword">in</span> reader]
    <span class="keyword">with</span> <span class="method">open</span>(json_path, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:
        json.dump(datos, f, indent=2, ensure_ascii=<span class="keyword">False</span>)</code></pre>

            <h3>Actividad Final (10 min)</h3>
            <p>En parejas:</p>
            <ol>
                <li>Guardar una lista de 5 productos en CSV</li>
                <li>Leer el CSV y mostrarlo en consola</li>
                <li>Serializar 1 producto a JSON</li>
                <li>Comprimir el archivo JSON con GZIP</li>
            </ol>

            <div class="info-box">
                <strong>Mini-Chequeo: Archivos Planos</strong>
                <ul>
                    <li>¿Cuándo elegir CSV vs JSON vs XML para persistencia?</li>
                    <li>¿Por qué es importante usar UTF-8 al escribir archivos?</li>
                    <li>¿Qué pasa si olvidas cerrar un archivo (sin context manager)?</li>
                </ul>
            </div>
        </section>

        <!-- Resumen -->
        <section>
            <h2>Resumen</h2>
            <table>
                <thead>
                    <tr>
                        <th>Concepto</th>
                        <th>Idea Clave</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>pathlib / open()</strong></td>
                        <td>API base para operaciones de archivos</td>
                    </tr>
                    <tr>
                        <td><strong>CSV</strong></td>
                        <td>Datos tabulares simples, compatible con Excel</td>
                    </tr>
                    <tr>
                        <td><strong>JSON</strong></td>
                        <td>Intercambio estructurado, estándar web</td>
                    </tr>
                    <tr>
                        <td><strong>XML</strong></td>
                        <td>Formato empresarial, soporta schemas</td>
                    </tr>
                    <tr>
                        <td><strong>Repository Pattern</strong></td>
                        <td>Abstracción de acceso a datos en archivos</td>
                    </tr>
                    <tr>
                        <td><strong>Compresión</strong></td>
                        <td>GZIP y ZIP para reducir tamaño</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Referencias -->
        <section id="entrega-git">
            <h2>Entrega con Git</h2>
            <pre><code>git checkout -b feature/archivos-planos-clase-14
git add src/ data/
git commit -m "chore: estructura inicial archivos planos"
git commit -m "feat: lectura/escritura CSV JSON XML"
git commit -m "docs: agrega notas y ejercicios"
git tag -a clase-14-v1 -m "Entrega clase 14 - archivos planos"</code></pre>
        </section>

        <section id="referencias">
            <h2>Referencias y Recursos Adicionales</h2>
            <h3>Documentación Oficial</h3>
            <ul>
                <li><a href="https://docs.python.org/3/library/pathlib.html" target="_blank" style="color: #1e40af;">pathlib - Python Docs</a></li>
                <li><a href="https://docs.python.org/3/library/csv.html" target="_blank" style="color: #1e40af;">csv - Python Docs</a></li>
                <li><a href="https://docs.python.org/3/library/json.html" target="_blank" style="color: #1e40af;">json - Python Docs</a></li>
            </ul>

            <h3>Próxima Clase</h3>
            <p><strong>Clase 15: Repositorios y Unit of Work con SQL Server</strong></p>
            <ul>
                <li>Patrón repositorio con pyodbc</li>
                <li>Unidad de trabajo y transacciones</li>
                <li>Sincronización de cambios</li>
            </ul>
        </section>
    </main>

    <section id="resumen">
      <h2>Resumen de la Clase</h2>
      <ul>
        <li>Archivos planos son útiles para configuraciones, logs y exportaciones.</li>
        <li>Python ofrece módulos estándar: pathlib, csv, json, xml.etree.</li>
        <li>El context manager evita fugas de recursos al trabajar con archivos.</li>
        <li>CSV es ideal para datos tabulares; JSON para APIs; XML para integraciones legacy.</li>
        <li>gzip/zipfile permiten compresión para backups y distribución.</li>
      </ul>
    </section>

    <footer>
        <p><strong>IF0100 - Lenguaje de Programación Orientada a Objetos II</strong></p>
        <p>UNAULA - Ingeniería Informática | 2026-I Semestre</p>
    </footer>
</body>
</html>
