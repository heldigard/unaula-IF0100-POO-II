<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Dominar Pydantic: BaseModel, Field, validaciones y schemas request/response. Curso IF0100 - POO II">
    <meta name="author" content="IF0100 - UNAULA">
    <title>Pydantic y Validación | IF0100 - POO II</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
          crossorigin="anonymous">

    <!-- Prism.js para syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
          rel="stylesheet">

    <style>
        :root {
            --primary-color: #0d6efd;
            --secondary-color: #6c757d;
            --success-color: #198754;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #0dcaf0;
            --light-bg: #f8f9fa;
            --dark-text: #212529;
            --border-color: #dee2e6;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.7;
            color: var(--dark-text);
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, var(--primary-color) 0%, #0a58ca 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        header h2 {
            font-size: 1.25rem;
            font-weight: 400;
            opacity: 0.9;
        }

        header h3 {
            font-size: 1rem;
            font-weight: 300;
            opacity: 0.8;
        }

        /* Navigation */
        .navbar {
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Sidebar */
        .sidebar {
            background-color: var(--light-bg);
            border-radius: 8px;
            padding: 1.5rem;
            position: sticky;
            top: 2rem;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .sidebar h5 {
            color: var(--primary-color);
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--primary-color);
        }

        .sidebar ul {
            list-style: none;
            padding-left: 0;
        }

        .sidebar li {
            margin-bottom: 0.5rem;
        }

        .sidebar a {
            color: var(--dark-text);
            text-decoration: none;
            padding: 0.5rem 0.75rem;
            display: block;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .sidebar a:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateX(5px);
        }

        /* Main Content */
        main {
            padding: 2rem 0;
        }

        section {
            margin-bottom: 3rem;
            padding: 1.5rem;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        section h2 {
            color: var(--primary-color);
            font-weight: 600;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 3px solid var(--primary-color);
        }

        section h3 {
            color: var(--dark-text);
            font-weight: 500;
            margin-top: 1.5rem;
            margin-bottom: 1rem;
        }

        section h4 {
            color: var(--secondary-color);
            font-weight: 500;
            margin-top: 1rem;
            margin-bottom: 0.75rem;
        }

        /* Lists */
        section ul, section ol {
            padding-left: 1.5rem;
            margin-bottom: 1rem;
        }

        section li {
            margin-bottom: 0.5rem;
        }

        /* Code Blocks */
        pre[class*="language-"] {
            border-radius: 6px;
            margin: 1rem 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        code[class*="language-"] {
            font-size: 0.9rem;
        }

        /* Alert Boxes */
        .alert-note {
            background-color: #e7f3ff;
            border-left: 4px solid var(--info-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .alert-warning-custom {
            background-color: #fff3cd;
            border-left: 4px solid var(--warning-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .alert-tip {
            background-color: #d1e7dd;
            border-left: 4px solid var(--success-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        .alert-error {
            background-color: #f8d7da;
            border-left: 4px solid var(--danger-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 4px;
        }

        /* Cards */
        .card {
            border: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        /* Tables */
        .table {
            margin: 1rem 0;
        }

        .table thead {
            background-color: var(--primary-color);
            color: white;
        }

        /* Footer */
        footer {
            background-color: var(--light-bg);
            padding: 2rem 0;
            margin-top: 3rem;
            text-align: center;
            border-top: 1px solid var(--border-color);
        }

        footer p {
            margin-bottom: 0.5rem;
            color: var(--secondary-color);
        }

        /* Print Styles */
        @media print {
            header {
                background: white !important;
                color: black !important;
                padding: 1rem 0;
            }

            .navbar, .sidebar, footer {
                display: none;
            }

            section {
                page-break-inside: avoid;
                box-shadow: none;
                border: 1px solid var(--border-color);
            }

            a {
                color: black;
                text-decoration: none;
            }

            a[href]:after {
                content: " (" attr(href) ")";
            }
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.5rem;
            }

            header h2 {
                font-size: 1rem;
            }

            .sidebar {
                position: static;
                max-height: none;
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <div class="container">
            <h1>IF0100 - Lenguaje de Programación OO II</h1>
            <h2>Unidad 3: Desarrollo Backend</h2>
            <h3>Clase 02: Pydantic y Validación</h3>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                    data-bs-target="#navbarNav"
                    aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html">Inicio</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#clases">Clases</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="../index.html#recursos">Recursos</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <!-- Sidebar -->
            <aside class="col-lg-3">
                <nav class="sidebar">
                    <h5>Contenido</h5>
                    <ul>
                        <li><a href="#objetivos">Objetivos de Aprendizaje</a></li>
                        <li><a href="#teoria">Conceptos Teóricos</a></li>
                        <li><a href="#basemodel">Pydantic BaseModel</a></li>
                        <li><a href="#field">Field y Validaciones</a></li>
                        <li><a href="#schemas">Schemas Request/Response</a></li>
                        <li><a href="#validacion-custom">Validación Personalizada</a></li>
                        <li><a href="#ejemplos">Ejemplos Prácticos</a></li>
                        <li><a href="#buenas-practicas">Buenas Prácticas</a></li>
                        <li><a href="#ejercicio">Ejercicio Guido</a></li>
                        <li><a href="#referencias">Para Profundizar</a></li>
                    </ul>
                </nav>
            </aside>

            <!-- Main Content Area -->
            <main class="col-lg-9">
                <!-- Sección 1: Objetivos -->
                <section id="objetivos">
                    <h2>Objetivos de Aprendizaje</h2>
                    <p>Al finalizar esta clase, usted será capaz de:</p>
                    <ul>
                        <li>Comprender qué es Pydantic y su relación con FastAPI</li>
                        <li>Crear modelos usando BaseModel de Pydantic</li>
                        <li>Aplicar validaciones automáticas con Field</li>
                        <li>Diferenciar schemas de request y response</li>
                        <li>Usar tipos complejos de Pydantic (List, Optional, etc.)</li>
                        <li>Personalizar mensajes de error de validación</li>
                        <li>Conectar schemas con modelos de dominio existentes</li>
                    </ul>
                </section>

                <!-- Sección 2: Conceptos Teóricos -->
                <section id="teoria">
                    <h2>Conceptos Teóricos</h2>

                    <h3>¿Qué es Pydantic?</h3>
                    <p>
                        <strong>Pydantic</strong> es una librería de Python para validación de datos
                        usando <strong>type hints</strong>. Es el corazón de FastAPI para:
                    </p>
                    <ul>
                        <li>Validar datos de entrada (request body)</li>
                        <li>Convertir datos (serialización/deserialización)</li>
                        <li>Documentar modelos automáticamente (OpenAPI)</li>
                        <li>Proveer autocompletado en editores</li>
                    </ul>

                    <div class="alert-tip">
                        <strong>Integración FastAPI + Pydantic:</strong>
                        FastAPI usa Pydantic para validar automáticamente todo el
                        request body, query parameters y path parameters.
                    </div>

                    <h3>Por qué usar Pydantic</h3>

                    <div class="row">
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-body">
                                    <h5 class="card-title">Validación Automática</h5>
                                    <p class="card-text">
                                        Los datos se validan automáticamente antes de que tu
                                        código se ejecute. Errores se convierten en HTTP 422.
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-body">
                                    <h5 class="card-title">Documentación Auto-Generada</h5>
                                    <p class="card-text">
                                        Los schemas Pydantic se convierten automáticamente en
                                        documentación OpenAPI en /docs.
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-body">
                                    <h5 class="card-title">Type Hints</h5>
                                    <p class="card-text">
                                        Usa type hints estándar de Python para definir tipos,
                                        lo que mejora el autocompletado.
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card">
                                <div class="card-body">
                                    <h5 class="card-title">Serialización</h5>
                                    <p class="card-text">
                                        Convierte automáticamente objetos Python a JSON y
                                        viceversa.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <h3>Schema Request vs Response</h3>

                    <table class="table table-striped">
                        <thead>
                            <tr>
                                <th>Schema</th>
                                <th>Propósito</th>
                                <th>Ejemplo</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Request</strong></td>
                                <td>Validar datos de entrada</td>
                                <td>UsuarioCreate (con password)</td>
                            </tr>
                            <tr>
                                <td><strong>Response</strong></td>
                                <td>Definir datos de salida</td>
                                <td>UsuarioResponse (sin password)</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="alert-warning-custom">
                        <strong>Importante:</strong> Nunca incluyas passwords en schemas de response.
                        Usa schemas diferentes para request y response.
                    </div>
                </section>

                <!-- Sección 3: BaseModel -->
                <section id="basemodel">
                    <h2>Pydantic BaseModel</h2>

                    <h3>Crear un Schema Básico</h3>

                    <pre><code class="language-python">from pydantic import BaseModel

class UsuarioBase(BaseModel):
    """Schema base de usuario."""
    username: str
    email: str
    nombre_completo: str | None = None  # Python 3.10+
    # o: from typing import Optional
    # nombre_completo: Optional[str] = None</code></pre>

                    <h3>Uso en FastAPI</h3>

                    <pre><code class="language-python">from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class UsuarioCreate(BaseModel):
    """Schema para crear usuario."""
    username: str
    email: str
    password: str

@app.post("/usuarios")
def crear_usuario(usuario: UsuarioCreate):
    """
    FastAPI valida automáticamente:
    - username, email, password están presentes
    - Son del tipo correcto (str)
    """
    return {
        "mensaje": "Usuario creado",
        "username": usuario.username,
        "email": usuario.email
        # Note: password NO se retorna (seguridad)
    }</code></pre>

                    <h3>Serialización Automática</h3>

                    <pre><code class="language-python">from pydantic import BaseModel

class Usuario(BaseModel):
    id: int
    username: str
    email: str

# Crear instancia
usuario = Usuario(id=1, username="juan", email="juan@example.com")

# Convertir a dict (JSON serializable)
usuario_dict = usuario.dict()
# {'id': 1, 'username': 'juan', 'email': 'juan@example.com'}

# Convertir a JSON
usuario_json = usuario.json()
# '{"id": 1, "username": "juan", "email": "juan@example.com"}'</code></pre>

                    <h3>Herencia de Schemas</h3>

                    <pre><code class="language-python">from pydantic import BaseModel

class UsuarioBase(BaseModel):
    """Campos compartidos por todos los schemas de usuario."""
    username: str
    email: str
    nombre_completo: str | None = None

class UsuarioCreate(UsuarioBase):
    """Schema para crear usuario (agrega password)."""
    password: str

class UsuarioResponse(UsuarioBase):
    """Schema para respuesta (agrega campos calculados)."""
    id: int
    activo: bool = True
    creado_en: str | None = None  # ISO format

class UsuarioUpdate(BaseModel):
    """Schema para actualizar usuario (todos opcionales)."""
    email: str | None = None
    nombre_completo: str | None = None
    activo: bool | None = None</code></pre>

                    <h3>Configuración de BaseModel</h3>

                    <pre><code class="language-python">from pydantic import BaseModel, ConfigDict

class Usuario(BaseModel):
    """Modelo Pydantic con configuración."""
    id: int
    username: str
    email: str

    model_config = ConfigDict(
        str_strip_whitespace=True,  # Limpiar espacios en strings
        validate_assignment=True,     # Validar al asignar atributos
        extra='forbid',               # Rechazar campos extra
        json_schema_extra={           # Metadata para OpenAPI
            "example": {
                "id": 1,
                "username": "juan",
                "email": "juan@example.com"
            }
        }
    )</code></pre>
                </section>

                <!-- Sección 4: Field y Validaciones -->
                <section id="field">
                    <h2>Field y Validaciones</h2>

                    <h3>Validaciones Básicas con Field</h3>

                    <pre><code class="language-python">from pydantic import BaseModel, Field

class UsuarioCreate(BaseModel):
    """Schema con validaciones."""
    username: str = Field(
        min_length=3,
        max_length=50,
        pattern="^[a-zA-Z0-9_]+$",  # Solo alfanuméricos y _
        description="Nombre de usuario único"
    )
    email: str = Field(
        pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$",  # Regex simple de email
        description="Email válido del usuario"
    )
    password: str = Field(
        min_length=8,
        max_length=100,
        description="Password (mínimo 8 caracteres)"
    )
    nombre_completo: str | None = Field(
        default=None,
        max_length=100,
        description="Nombre completo del usuario"
    )</code></pre>

                    <h3>Mensajes de Error Personalizados</h3>

                    <pre><code class="language-python">from pydantic import BaseModel, Field

class UsuarioCreate(BaseModel):
    username: str = Field(
        ...,
        min_length=3,
        max_length=50,
        description="Nombre de usuario único",
        json_schema_extra={
            "examples": ["juanperez", "maria_garcia"]
        }
    )
    email: str = Field(
        ...,
        pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$",
        description="Email válido"
    )
    password: str = Field(
        ...,
        min_length=8,
        description="Password (mínimo 8 caracteres)",
        json_schema_extra={
            "examples": ["pass1234", "SecurePass!2026"]
        }
    )

    # Mensajes personalizados
    nombre_completo: str | None = Field(
        default=None,
        max_length=100,
        json_schema_extra={
            "description": "Nombre completo",
            "examples": ["Juan Pérez", "María García"]
        }
    )</code></pre>

                    <h3>Validadores Comunes</h3>

                    <pre><code class="language-python">from pydantic import BaseModel, Field, EmailStr, HttpUrl, field_validator

class ProyectoCreate(BaseModel):
    """Schema para crear proyecto."""
    nombre: str = Field(
        ...,
        min_length=3,
        max_length=100,
        description="Nombre del proyecto"
    )
    descripcion: str | None = Field(
        default=None,
        max_length=500,
        description="Descripción del proyecto"
    )
    url_repositorio: HttpUrl | None = Field(
        default=None,
        description="URL del repositorio (opcional)"
    )
    usuario_email: EmailStr = Field(
        ...,
        description="Email del usuario propietario"
    )

    @field_validator('nombre')
    @classmethod
    def nombre_no_vacio(cls, v: str) -> str:
        """Valida que el nombre no esté vacío después de strip."""
        if not v or not v.strip():
            raise ValueError('El nombre no puede estar vacío')
        return v.strip()

    @field_validator('descripcion')
    @classmethod
    def descripcion_no_vacia_si_se_provee(cls, v: str | None) -> str | None:
        """Valida descripción si se provee."""
        if v is not None and not v.strip():
            raise ValueError('La descripción no puede estar vacía')
        return v if v is None else v.strip()</code></pre>

                    <h3>Números y Fechas</h3>

                    <pre><code class="language-python">from pydantic import BaseModel, Field, field_validator
from datetime import datetime
from typing import Optional

class TareaCreate(BaseModel):
    """Schema para crear tarea."""
    titulo: str = Field(
        ...,
        min_length=3,
        max_length=200
    )
    prioridad: int = Field(
        default=2,
        ge=1,  # Greater than or equal to 1
        le=5   # Less than or equal to 5
    )
    fecha_limite: Optional[datetime] = None
    porcentaje_completado: float = Field(
        default=0.0,
        ge=0.0,   # Mínimo 0
        le=100.0  # Máximo 100
    )

    @field_validator('fecha_limite')
    @classmethod
    def fecha_limite_futuro(cls, v: Optional[datetime]) -> Optional[datetime]:
        """Valida que la fecha límite sea futura."""
        if v is not None and v < datetime.now():
            raise ValueError('La fecha límite debe ser futura')
        return v</code></pre>
                </section>

                <!-- Sección 5: Schemas Request/Response -->
                <section id="schemas">
                    <h2>Schemas Request/Response</h2>

                    <h3>Patrón Base-Create-Response</h3>

                    <pre><code class="language-python"># schemas/usuario.py

from pydantic import BaseModel, EmailStr, Field, ConfigDict
from typing import Optional
from datetime import datetime

class UsuarioBase(BaseModel):
    """Campos base compartidos."""
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    nombre_completo: Optional[str] = Field(None, max_length=100)

class UsuarioCreate(UsuarioBase):
    """Schema para crear usuario (INCLUYE PASSWORD)."""
    password: str = Field(..., min_length=8)

class UsuarioUpdate(BaseModel):
    """Schema para actualizar usuario (TODOS OPCIONALES)."""
    email: Optional[EmailStr] = None
    nombre_completo: Optional[str] = Field(None, max_length=100)
    password: Optional[str] = Field(None, min_length=8)

class UsuarioResponse(UsuarioBase):
    """Schema para respuesta (SIN PASSWORD, con ID)."""
    id: int
    activo: bool = True
    creado_en: datetime

    model_config = ConfigDict(from_attributes=True)  # Pydantic v2</code></pre>

                    <h3>Usar Schemas en FastAPI</h3>

                    <pre><code class="language-python"># main.py
from fastapi import FastAPI, HTTPException, status
from typing import List
from schemas.usuario import UsuarioCreate, UsuarioResponse

app = FastAPI()

# Base de datos simulada
db_usuarios = []
next_id = 1

@app.post("/usuarios", response_model=UsuarioResponse, status_code=201)
def crear_usuario(usuario: UsuarioCreate):
    """
    Crea un nuevo usuario.

    - request body: UsuarioCreate (con password)
    - response: UsuarioResponse (sin password)
    """
    global next_id

    # Verificar duplicados
    for u in db_usuarios:
        if u["username"] == usuario.username:
            raise HTTPException(
                status_code=400,
                detail="Username ya existe"
            )

    # Crear usuario
    nuevo_usuario = UsuarioResponse(
        id=next_id,
        username=usuario.username,
        email=usuario.email,
        nombre_completo=usuario.nombre_completo,
        activo=True,
        creado_en=datetime.now()
    )

    db_usuarios.append(nuevo_usuario.dict())
    next_id += 1

    return nuevo_usuario

@app.get("/usuarios", response_model=List[UsuarioResponse])
def listar_usuarios():
    """Retorna lista de usuarios SIN passwords."""
    return db_usuarios

@app.get("/usuarios/{usuario_id}", response_model=UsuarioResponse)
def obtener_usuario(usuario_id: int):
    """Retorna un usuario específico."""
    for usuario in db_usuarios:
        if usuario["id"] == usuario_id:
            return usuario

    raise HTTPException(status_code=404, detail="Usuario no encontrado")</code></pre>

                    <h3>Schemas Anidados</h3>

                    <pre><code class="language-python">from pydantic import BaseModel
from typing import List

class TareaResponse(BaseModel):
    """Schema de tarea."""
    id: int
    titulo: str
    estado: str

class ProyectoResponse(BaseModel):
    """Schema de proyecto CON tareas anidadas."""
    id: int
    nombre: str
    tareas: List[TareaResponse] = []  # Lista anidada

@app.get("/proyectos/{proyecto_id}", response_model=ProyectoResponse)
def obtener_proyecto(proyecto_id: int):
    """Retorna proyecto con sus tareas."""
    # ... código que obtiene proyecto con tareas
    return proyecto</code></pre>
                </section>

                <!-- Sección 6: Validación Personalizada -->
                <section id="validacion-custom">
                    <h2>Validación Personalizada</h2>

                    <h3>Validadores con @field_validator</h3>

                    <pre><code class="language-python">from pydantic import BaseModel, field_validator, ValidationInfo

class UsuarioCreate(BaseModel):
    username: str
    email: str
    password: str
    password_confirm: str

    @field_validator('username')
    @classmethod
    def username_alphanumerico(cls, v: str) -> str:
        """Valida que username sea alfanumérico."""
        if not v.isalnum():
            raise ValueError('Username debe ser alfanumérico')
        return v

    @field_validator('password_confirm')
    @classmethod
    def passwords_coinciden(cls, v: str, info: ValidationInfo) -> str:
        """Valida que passwords coincidan."""
        if 'password' in info.data and v != info.data['password']:
            raise ValueError('Los passwords no coinciden')
        return v

    @field_validator('password')
    @classmethod
    def password_fuerte(cls, v: str) -> str:
        """Valida que el password sea fuerte."""
        if len(v) < 8:
            raise ValueError('Password muy corto (mínimo 8)')
        if not any(c.isupper() for c in v):
            raise ValueError('Password debe tener al menos una mayúscula')
        if not any(c.isdigit() for c in v):
            raise ValueError('Password debe tener al menos un número')
        return v</code></pre>

                    <h3>Validador con Múltiples Campos</h3>

                    <pre><code class="language-python">from pydantic import BaseModel, field_validator, ValidationInfo, model_validator

class ProyectoCreate(BaseModel):
    nombre: str
    usuario_id: int
    fecha_inicio: datetime | None = None
    fecha_fin: datetime | None = None

    @model_validator(mode='after')
    def validar_fechas(self) -> 'ProyectoCreate':
        """Valida que fecha_fin sea posterior a fecha_inicio."""
        if self.fecha_inicio and self.fecha_fin:
            if self.fecha_fin <= self.fecha_inicio:
                raise ValueError('fecha_fin debe ser posterior a fecha_inicio')
        return self</code></pre>

                    <h3>Root Validators (Pydantic v2)</h3>

                    <pre><code class="language-python">from pydantic import BaseModel, model_validator

class TareaUpdate(BaseModel):
    titulo: str | None = None
    estado: str | None = None
    prioridad: int | None = None

    @model_validator(mode='after')
    def validar_estado_prioridad(cls, model: 'TareaUpdate') -> 'TareaUpdate':
        """Valida combinación de estado y prioridad."""
        if model.estado == "completada" and model.prioridad == 1:
            # Tarea completada no puede ser prioridad urgente
            model.prioridad = 3  # Bajar prioridad automáticamente
        return model</code></pre>
                </section>

                <!-- Sección 7: Ejemplos Prácticos -->
                <section id="ejemplos">
                    <h2>Ejemplos Prácticos</h2>

                    <h3>Ejemplo 1: Schemas Completos de Usuario</h3>

                    <pre><code class="language-python"># schemas/usuario.py

from pydantic import BaseModel, EmailStr, Field, ConfigDict, field_validator
from typing import Optional
from datetime import datetime

class UsuarioBase(BaseModel):
    """Campos base de usuario."""
    username: str = Field(
        ...,
        min_length=3,
        max_length=50,
        pattern="^[a-zA-Z0-9_]+$"
    )
    email: EmailStr
    nombre_completo: Optional[str] = Field(None, max_length=100)

class UsuarioCreate(UsuarioBase):
    """Schema para crear usuario."""
    password: str = Field(..., min_length=8)
    password_confirm: str

    @field_validator('password_confirm')
    @classmethod
    def passwords_coinciden(cls, v: str, info: ValidationInfo) -> str:
        if 'password' in info.data and v != info.data['password']:
            raise ValueError('Los passwords no coinciden')
        return v

class UsuarioUpdate(BaseModel):
    """Schema para actualizar usuario."""
    email: Optional[EmailStr] = None
    nombre_completo: Optional[str] = Field(None, max_length=100)
    password: Optional[str] = Field(None, min_length=8)

class UsuarioInDB(UsuarioBase):
    """Usuario como está en BD."""
    id: int
    password_hash: str
    activo: bool = True
    creado_en: datetime

    model_config = ConfigDict(from_attributes=True)

class UsuarioResponse(UsuarioBase):
    """Usuario en respuesta (sin password)."""
    id: int
    activo: bool = True
    creado_en: datetime</code></pre>

                    <h3>Ejemplo 2: Schemas con Relaciones</h3>

                    <pre><code class="language-python">from pydantic import BaseModel
from typing import List, Optional

class TareaBase(BaseModel):
    titulo: str
    descripcion: Optional[str] = None
    estado: str = "pendiente"
    prioridad: int = 2

class TareaCreate(TareaBase):
    """Schema para crear tarea."""
    proyecto_id: int

class TareaResponse(TareaBase):
    """Schema de respuesta de tarea."""
    id: int
    proyecto_id: int
    creada_por: int

class ProyectoBase(BaseModel):
    nombre: str
    descripcion: Optional[str] = None

class ProyectoCreate(ProyectoBase):
    """Schema para crear proyecto."""
    usuario_id: int

class ProyectoResponse(ProyectoBase):
    """Schema de respuesta de proyecto."""
    id: int
    usuario_id: int
    activo: bool = True
    tareas: List[TareaResponse] = []</code></pre>

                    <h3>Ejemplo 3: Conexión con Modelos de Dominio</h3>

                    <pre><code class="language-python"># schemas/usuario.py

from pydantic import BaseModel
from models.usuario import Usuario as UsuarioModel

class UsuarioResponse(BaseModel):
    """Schema compatible con modelo de dominio."""
    id: int
    username: str
    email: str
    activo: bool

    @classmethod
    def from_model(cls, usuario: UsuarioModel) -> 'UsuarioResponse':
        """Crea schema desde modelo de dominio."""
        return cls(
            id=usuario.id,
            username=usuario.username,
            email=usuario.email,
            activo=usuario.activo
        )

# Uso en endpoint
@app.get("/usuarios/{usuario_id}")
def obtener_usuario(usuario_id: int):
    usuario_model = repo.obtener_por_id(usuario_id)
    return UsuarioResponse.from_model(usuario_model)</code></pre>
                </section>

                <!-- Sección 8: Buenas Prácticas -->
                <section id="buenas-practicas">
                    <h2>Buenas Prácticas</h2>

                    <h3>Organización de Schemas</h3>

                    <pre><code class="language-text">schemas/
├── __init__.py
├── usuario.py          # UsuarioBase, Create, Update, Response
├── proyecto.py         # ProyectoBase, Create, Update, Response
└── tarea.py            # TareaBase, Create, Update, Response</code></pre>

                    <h3>DO's con Pydantic</h3>

                    <ul>
                        <li><strong>Usa Field para validaciones:</strong> Más expresivo que type hints solos</li>
                        <li><strong>Crea schemas separados:</strong> Create, Update, Response</li>
                        <li><strong>Nunca incluyas passwords en response:</strong> Vulnerabilidad de seguridad</li>
                        <li><strong>Usa from_attributes=True:</strong> Para crear desde modelos ORM</li>
                        <li><strong>Documenta con description:</strong> Aparece en /docs</li>
                        <li><strong>Usa examples:</strong> Para mostrar ejemplos en documentación</li>
                    </ul>

                    <h3>DON'T's con Pydantic</h3>

                    <ul>
                        <li><strong No uses el mismo schema para request/response:</strong> Problema de seguridad</li>
                        <li><strong No omitas validaciones:</strong> Siempre valida datos de entrada</li>
                        <li><strong No mezclas lógica de negocio:</strong> Solo validación de datos</li>
                        <li><strong No uses schemas como modelos:</strong> Los modelos son otra capa</li>
                    </ul>

                    <h3>Patrón Base-Create-Update-Response</h3>

                    <pre><code class="language-python"># Patrón recomendado

# 1. Base: campos compartidos
class UsuarioBase(BaseModel):
    username: str
    email: EmailStr

# 2. Create: para POST (agrega campos requeridos)
class UsuarioCreate(UsuarioBase):
    password: str

# 3. Update: para PUT/PATCH (todos opcionales)
class UsuarioUpdate(BaseModel):
    email: Optional[EmailStr] = None
    password: Optional[str] = None

# 4. Response: para GET (sin passwords sensibles)
class UsuarioResponse(UsuarioBase):
    id: int
    creado_en: datetime</code></pre>
                </section>

                <!-- Sección 9: Ejercicio Guido -->
                <section id="ejercicio">
                    <h2>Ejercicio Guido: Schemas para Usuario</h2>

                    <h3>Objetivo</h3>
                    <p>
                        Crear schemas Pydantic completos para el modelo Usuario de TaskFlow,
                        conectándolos con la estructura existente del proyecto.
                    </p>

                    <h3>Instrucciones Paso a Paso</h3>

                    <h4>Paso 1: Crear Estructura de Schemas (2 min)</h4>

                    <pre><code class="language-bash"># Crear directorio
mkdir -p schemas
touch schemas/__init__.py</code></pre>

                    <h4>Paso 2: Schema Base (5 min)</h4>

                    <pre><code class="language-python"># schemas/usuario.py

from pydantic import BaseModel, EmailStr, Field, field_validator
from typing import Optional
from datetime import datetime

class UsuarioBase(BaseModel):
    """
    Schema base con campos compartidos.

    Estos campos se usan tanto para crear como
    para responder usuarios.
    """
    username: str = Field(
        ...,
        min_length=3,
        max_length=50,
        pattern="^[a-zA-Z0-9_]+$",
        description="Nombre de usuario único (solo alfanuméricos y _)"
    )
    email: EmailStr = Field(
        ...,
        description="Email válido del usuario"
    )
    nombre_completo: Optional[str] = Field(
        default=None,
        max_length=100,
        description="Nombre completo del usuario"
    )</code></pre>

                    <h4>Paso 3: Schema Create (5 min)</h4>

                    <pre><code class="language-python"># Agregar a schemas/usuario.py

class UsuarioCreate(UsuarioBase):
    """
    Schema para crear un nuevo usuario.

    Incluye password que no está en el base
    y password_confirm para verificación.
    """
    password: str = Field(
        ...,
        min_length=8,
        max_length=100,
        description="Password (mínimo 8 caracteres)"
    )
    password_confirm: str

    @field_validator('password_confirm')
    @classmethod
    def passwords_coinciden(cls, v: str, info) -> str:
        """Valida que los passwords coincidan."""
        if 'password' in info.data and v != info.data['password']:
            raise ValueError('Los passwords no coinciden')
        return v

    @field_validator('password')
    @classmethod
    def password_valido(cls, v: str) -> str:
        """Valida requisitos del password."""
        if len(v) < 8:
            raise ValueError('Password muy corto (mínimo 8 caracteres)')
        return v</code></pre>

                    <h4>Paso 4: Schema Response (5 min)</h4>

                    <pre><code class="language-python"># Agregar a schemas/usuario.py

class UsuarioResponse(UsuarioBase):
    """
    Schema para respuesta de usuario.

    NO incluye password por seguridad.
    Incluye campos calculados/derivados.
    """
    id: int
    activo: bool = True
    creado_en: datetime

    class Config:
        from_attributes = True  # Pydantic v2
        # o para Pydantic v1: orm_mode = True</code></pre>

                    <h4>Paso 5: Schema Update (3 min)</h4>

                    <pre><code class="language-python"># Agregar a schemas/usuario.py

class UsuarioUpdate(BaseModel):
    """
    Schema para actualizar usuario.

    Todos los campos son opcionales para permitir
    actualizaciones parciales.
    """
    email: Optional[EmailStr] = None
    nombre_completo: Optional[str] = Field(None, max_length=100)
    password: Optional[str] = Field(None, min_length=8)
    activo: Optional[bool] = None</code></pre>

                    <h4>Paso 6: Usar Schemas en FastAPI (10 min)</h4>

                    <pre><code class="language-python"># main.py
from fastapi import FastAPI, HTTPException, status
from schemas.usuario import UsuarioCreate, UsuarioResponse, UsuarioUpdate

app = FastAPI()

# Base de datos simulada
db_usuarios = []
next_id = 1

@app.post("/usuarios", response_model=UsuarioResponse, status_code=201)
def crear_usuario(usuario: UsuarioCreate):
    """
    Crea un nuevo usuario.

    El request body se valida automáticamente con UsuarioCreate.
    La respuesta se formatea con UsuarioResponse.
    """
    global next_id

    # Verificar username único
    for u in db_usuarios:
        if u["username"] == usuario.username:
            raise HTTPException(status_code=400, detail="Username ya existe")

    # Crear usuario (sin password en response)
    nuevo_usuario = UsuarioResponse(
        id=next_id,
        username=usuario.username,
        email=usuario.email,
        nombre_completo=usuario.nombre_completo,
        activo=True,
        creado_en=datetime.now()
    )

    db_usuarios.append(nuevo_usuario.model_dump())
    next_id += 1

    return nuevo_usuario

@app.get("/usuarios", response_model=list[UsuarioResponse])
def listar_usuarios():
    """Lista todos los usuarios."""
    return db_usuarios

@app.put("/usuarios/{usuario_id}", response_model=UsuarioResponse)
def actualizar_usuario(usuario_id: int, usuario: UsuarioUpdate):
    """Actualiza un usuario."""
    # Buscar usuario
    usuario_existente = None
    for u in db_usuarios:
        if u["id"] == usuario_id:
            usuario_existente = u
            break

    if not usuario_existente:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")

    # Actualizar solo campos proveídos
    if usuario.email is not None:
        usuario_existente["email"] = usuario.email
    if usuario.nombre_completo is not None:
        usuario_existente["nombre_completo"] = usuario.nombre_completo
    if usuario.activo is not None:
        usuario_existente["activo"] = usuario.activo

    return UsuarioResponse(**usuario_existente)</code></pre>

                    <h4>Paso 7: Probar Validación (5 min)</h4>

                    <pre><code class="language-bash"># Probar con validaciones correctas
curl -X POST http://localhost:8000/usuarios \
  -H "Content-Type: application/json" \
  -d '{
    "username": "juan",
    "email": "juan@example.com",
    "password": "pass1234",
    "password_confirm": "pass1234"
  }'

# Probar validación de username corto (debe fallar)
curl -X POST http://localhost:8000/usuarios \
  -H "Content-Type: application/json" \
  -d '{
    "username": "ab",
    "email": "test@example.com",
    "password": "pass1234",
    "password_confirm": "pass1234"
  }'</code></pre>

                    <h3>Conexión con TaskFlow</h3>
                    <p>
                        Los schemas que estás creando hoy son la interfaz de la API REST de TaskFlow.
                        Estos schemas:
                    </p>
                    <ul>
                        <li>Validan automáticamente todos los datos de entrada</li>
                        <li>Documentan la API en /docs</li>
                        <li>Protegen contra datos inválidos o maliciosos</li>
                        <li>Facilitan el frontend (know what to expect)</li>
                    </ul>

                    <h3>Resultado Esperado</h3>
                    <p>Al finalizar este ejercicio, tendrás:</p>
                    <ul>
                        <li>✅ UsuarioBase con campos compartidos</li>
                        <li>✅ UsuarioCreate con validaciones</li>
                        <li>✅ UsuarioResponse sin passwords</li>
                        <li>✅ UsuarioUpdate con campos opcionales</li>
                        <li>✅ Endpoints usando los schemas</li>
                        <li>✅ Validación automática probada</li>
                        <li>✅ Base para schemas de Proyecto y Tarea</li>
                    </ul>
                </section>

                <!-- Sección 10: Referencias -->
                <section id="referencias">
                    <h2>Para Profundizar</h2>
                    <ul>
                        <li>
                            <a href="https://docs.pydantic.dev/latest/" target="_blank">
                                Documentación Oficial de Pydantic
                            </a>
                        </li>
                        <li>
                            <a href="https://fastapi.tiangolo.com/tutorial/body/" target="_blank">
                                FastAPI Tutorial - Request Body
                            </a>
                        </li>
                        <li>
                            <a href="https://www.youtube.com/watch?v=tM6ar0dGVJE" target="_blank">
                                Video: Pydantic v2 Tutorial
                            </a>
                        </li>
                        <li>
                            <a href="https://github.com/pydantic/pydantic" target="_blank">
                                Pydantic en GitHub
                            </a>
                        </li>
                    </ul>
                </section>
            </main>
        </div>
    </div>

    <!-- Boton de Notebook -->
    <div class="alert-tip mt-4">
        <span class="btn btn-warning disabled" style="cursor: not-allowed;">
            <i class="bi bi-clock me-2"></i>⚠️ Notebook pendiente de creacion
        </span>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2026 IF0100 - UNAULA | Todos los derechos reservados</p>
            <p>Nota: El link de Google Colab se activara cuando el notebook sea creado.</p>
            <p>Ultima actualizacion: 2026-02-08</p>
        </div>
    </footer>

    <!-- Bootstrap 5 JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
            crossorigin="anonymous"></script>

    <!-- Prism.js Core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>

    <!-- Prism.js Language Support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>

    <!-- Highlight code on page load -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            Prism.highlightAll();
        });
    </script>
</body>
</html>
